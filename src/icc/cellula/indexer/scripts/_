OrderedDict([('doc', <Graph identifier=doc (<class 'rdflib.graph.Graph'>)>)])
15193888177428402282	5154028476621783295	"<html><head><title></title>\n<meta http-equiv='Content-Type' content='text/html;charset=UTF-8'>\n</head>\n<body>\n<p>\nМИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ<br>\n<br>\n<br>\n      Федеральное государственное бюджетное образовательное учреждение<br>\n                    высшего профессионального образования<br>\n<br>\n<br>\n                  «ИРКУТСКИЙ  ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ»<br>\n                              (ФГБОУ ВПО «ИГУ»)<br>\n<br>\n<br>\n<br>\n<br>\n      Институт математики,                   Кафедра проблем управления и<br>\n      экономики и информатики                информатики<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n                                    ОТЧЕТ<br>\n                          О ПРЕДДИПЛОМНОЙ ПРАКТИКЕ<br>\n              _________________________________________________<br>\n                         (вид и  название практики)<br>\n                            10.01.12 – 03.04.2012<br>\n      _________________________________________________________________<br>\n                        (сроки проведения  практики)<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n                                                Студента 5 курса группы 2531<br>\n                                                   Специальности 010501.65 –<br>\n                                                             «Математическое<br>\n                                             обеспечение и администрирование<br>\n                                                      информационных систем»<br>\n                                                            Воронкова Андрея<br>\n                                                               Владимировича<br>\n<br>\n<br>\n                                                      Руководитель от ИДСТУ:<br>\n                                                 кандидат тех. наук, доцент,<br>\n                                              Черкашин Евгений Александрович<br>\n<br>\n<br>\n                                                 Оценка ____________________<br>\n<br>\n<br>\n                              Иркутск – 2012<br>\n      Место прохождения преддипломной практики:<br>\n<br>\n      ИДСТУ<br>\n<br>\n      Тема выпускной квалификационной работы:<br>\n<br>\n         Разработка системы анализа и решения проблем локальной сети<br>\n      Формулировка индивидуального задания:<br>\n      Целью дипломной работы  является  создание  программного  обеспечения,<br>\nобеспечивающего контроль  корректной  работы  сети.  Разработать  экспертную<br>\nсистему для автоматического анализа и решения проблем в работе сети  .  База<br>\nзнаний экспертной системы  должна  быть  легко  расширяема,  для  увеличения<br>\nчисла задач, выполняемых системой.<br>\n      Исходя из цели дипломной работы, были поставлены следующие задачи:<br>\n         • Создать сканер локальной  сети  для  построения  в  виде  графа,<br>\n           используя библиотеку JGraph; добавить  возможностью  мониторинга<br>\n           сети в режиме реального времени с выполнением удалённых команд и<br>\n           изменением сетевых параметров;<br>\n         • Изучение всех этапов разработки экспертных систем и создание  на<br>\n           языке программирования Java двух экспертных систем:<br>\n               o Для анализа состояния сети и выявления проблем;<br>\n               o Для решения выявленной проблемы и составления отчёта.<br>\n      Пользователя для работы экспертной системы нет,  ответами  на  вопросы<br>\nявляются возвращаемые значения методов<br>\n         • Создание базы знаний для экспертной сети на MySQL;<br>\n         • Разработка клиент-серверного приложения для работы с сетью.<br>\n<br>\n<br>\n      Объектами изучения в ходе выполнения дипломной работы стали:<br>\n         • объектно-ориентированный язык программирования Java. Изучены<br>\n           основные библиотеки и дополнительные SNMP4J, JDBC, XStream.<br>\n         • экспертные системы, их структура, разработка и использование с<br>\n           базами знаний.<br>\n         • СУБД MySQL, для хранения базы знаний экспертных систем.<br>\n         • Изучение популярных сетевых оборудований (маршрутизаторы,<br>\n           коммуникаторы, сетевые карты, и т.д.) для программного обращения<br>\n           к оборудованию через протокол SNMP.<br>\n         • Администрирование локальной сети и сетевого оборудования.<br>\n<br>\n<br>\n      Основные полученные результаты<br>\n      Выполнены следующие задачи дипломной работы:<br>\n         • Изучены принципы администрирований локальной  сети,  разработаны<br>\n           системы анализа скорости  и  работы  сети,  разработана  система<br>\n           решения возможных проблем.<br>\n         • Изучены этапы разработки экспертных систем;<br>\n         • Разработаны две экспертные  системы  на  языке  программирования<br>\n           Java;<br>\n         • Разработаны базы знаний на MySQL;<br>\n         • Разработано клиент-серверное приложение для автоматизации работы<br>\n           в сети.<br>\n<br>\n<br>\n      Выводы, вытекающие из проделанной работы<br>\n      Изученные  методы  достаточно  подробно  разработаны  и  описаны.  Они<br>\nподходят для дальнейшего выполнения  дипломной  работы  «Разработка  системы<br>\nанализа и решения проблем локальной сети»<br>\n<br>\n<br>\n<br>\n<br>\n      Список изученной литературы<br>\n   1. Джозеф Джарратано, Гари Райли «Экспертные системы: принципы разработки<br>\n      и программирование» : Пер. с англ. — М. : Издательский дом «Вильямс»,<br>\n      2006. — 1152 стр. с ил.<br>\n<br>\n      2.    Герберт Шилдт, «Java. Полное руководство»: Пер. с англ. — М. :<br>\nИздательский дом «Вильямс», 2006. — 1104 стр. с ил.<br>\n<br>\n      3.    JGraphX Version 1.9.2.4 – 30. March 2012, Copyright (c) JGraph<br>\nLtd 2006-2012, http://www.jgraph.com/doc/mxgraph/index_javavis.html<br>\n      4.    XStream Core  http://xstream.codehaus.org/javadoc/index.html<br>\n<br>\n<br>\n      5. JDBC User Manual<br>\nhttp://java.sun.com/docs/books/tutorial/jdbc/index.html<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n      Отзыв руководителя<br>\n<br>\n<br>\n      Воронков А.В.  во  время  преддипломной  практики  занимался  анализом<br>\nтопологии  и   программных   сервисов   сети   предприятия,   где   проходил<br>\nпреддипломную практику. В  результате  анализа  выявлена  структура  сети  и<br>\nформализованы требования к  ее  корректному  функционированию,  а  также  ее<br>\nпропускной  способности.  Требования  представлены  в  кратком   отчете   по<br>\nпреддипломной практике.<br>\n      Воронков А.В. изучил средства  интеграции  средств  интеллектуализации<br>\nпрограммного обеспечения в программы на языке программирования Java.<br>\n      За время преддипломной практики Воронков А.В. показал себя как молодой<br>\nспециалист,  способный  не  только  решать   поставленные   задачи,   но   и<br>\nподготавливать технические задания для новых задач.<br>\n      Считаю,  что  результаты  работы  Воронкова  А.В.  заслуживают  оценки<br>\n«отлично».<br>\n<br>\n<br>\n<br>\n<br>\n      |Руководитель практики,   |                         |                         |<br>\n|к.т.н., доцент каф. ИТ   |                         |Черкашин Е.А.            |<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n      Отчет  рассмотрен и утвержден  на заседании кафедры<br>\n      Протокол №  , дата<br>\n<br>\n<br>\n                                                Подпись заведующего кафедрой<br>\n</p></body></html>\n"
2880448733259875423	12543946352603002308	"Министерство образования и науки Российской Федерации\nФедеральное государственное бюджетное образовательное\nучреждение высшего профессионального образования\n«Иркутский государственный университет»\nИнститут математики, экономики и информатики\nКОМПЬЮТЕРНЫЕ НАУКИ\nВ четырех частях\nЧасть 4\nЕ. А. Черкашин\nСистемы искусственного интеллекта\nУчебное пособие УДК 681.3(075.8)\nББК 32.97я73\nК63\nПечатается по решению ученого совета ИМЭИ\nИздание выходит в рамках Программы стратегического развития\nФГБОУ ВПО «ИГУ» на 2012–2016 гг., проект Р121-02-001\nРецензенты:\nд-р физ.-мат. наук В. И. Сажин, канд. техн. наук А. О. Шигаров\nК63\nКомпьютерные науки : учеб. пособие. В 4 ч. – Иркутск : Из-во ИГУ,\n2014.\nЧ. 4. Системы искусственного интеллекта / Е. А. Черкашин – 108 c.\nISBN 978-5-9624-1255-9 (ч. 4)\nISBN 978-5-9624-1251-1\nПервая часть учебного пособия включает разделы: «Информация и данные», «Вы-\nчислительная система», «Устройство персонального компьютера», «Системное и при-\nкладное программное обеспечение», «Компьютерные сети»; вторая – «Программиро-\nвание», третья – «Базы данных и СУБД», четвёртая часть – «Системы искусственного\nинтеллекта».\nПредназначено для студентов вузов, обучающихся по направлениям «Математика»,\n«Прикладная математика и информатика», «Математическое обеспечение и администри-\nрование информационных систем», «Информационная безопасность».\nУДК 681.3 (075.8)\nББК 32.97я73\nУчебное издание\nКОМПЬЮТЕРНЫЕ НАУКИ\nВ четырех частях\nЧасть 4\nЕвгений Александрович Черкашин\nСистемы искусственного интеллекта\nРедактор В. В. Попова. Дизайн обложки П. О. Ершов\nТемплан 2014 г. Поз. 138. Подписано в печать 22.12.2014.\nФормат 60 × 90/16. Усл. печ. л. 6,2. Уч.-изд. л. 6,8. Тираж 100 экз. Заказ 182\nИздательство ИГУ; 664003, г. Иркутск, бульвар Гагарина, 36\nISBN 978-5-9624-1255-9 (ч. 4)\nISBN 978-5-9624-1251-1\n© Черкашин Е. А., 2014\n© ФГБОУ ВПО «ИГУ», 2014 Оглавление\nПредисловие 4\n1. Информатика и искусственный интеллект 8\n1.1. Определения . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.2. Формализмы представления знаний . . . . . . . . . . 23\n2. Логические модели и логическое программирование 25\n3. Планирование действий\n32\n3.1. Списки . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n3.2. Алгоритмы планирования действий . . . . . . . . . . 41\n3.3. Использование дополнительной информации . . . . 51\n4. Поиск решения на основе перебора\n4.1. Алгоритм British Museum . . . . . . . . . . . . . . . .\n5. Компьютерная алгебра\n70\n71\n77\n5.1. Символьное дифференцирование . . . . . . . . . . . . 77\n5.2. Оптимальное управление . . . . . . . . . . . . . . . . 84\nЗаключение 105\nРекомендуемая литература 107 Предисловие\nИнтерес математиков к решению сложных задач при помощи\nвычислительной техники постоянно возрастает. Разрабатывают-\nся программные пакеты автоматизации выполнения математи-\nческих операций и даже решения стандартных задач в автома-\nтическом режиме. Алгоритмы, реализованные в таких пакетах,\nиспользуют современные и классические методы поиска реше-\nния. Решение представляется в виде комбинации различных ва-\nриантов преобразования сложных структур данных, входных и\nвыходных переменных различных методов. Для того чтобы про-\nдуктивно пользоваться этими пакетами, необходимо изучать, как\nони работают, как получают требуемое решение.\nВ учебном пособии в форме тренинга (tutorial) представляют-\nся самые простые методики поиска решения дискретных задач,\nотносящихся к различным классам искусственного интеллек-\nта (ИИ): «логическое программирование», «планирование дей-\nствий», «решение задач в терминах ограничений» и «символь-\nные вычисления» («компьютерная алгебра»). Основная задача\nпособия состоит в выработке навыков автоматизации некоторых\nаспектов творческой деятельности математика при помощи вы-\nчислительных машин и классических средств реализации про-\nграмм из области ИИ. Навыки решения таких задач позволят в\nбудущем создавать собственные программные системы, реали-\nзующие новые методы, для которых еще не было разработано\nсоответствующего программного обеспечения.\n4 Предисловие\nПособие разработано для студентов, обучающихся по специ-\nальности «Математика», может быть использовано всеми заин-\nтересованными программистами, желающими овладеть некото-\nрыми методами искусственного интеллекта. Пособие включает\nподборку материала по курсам «Рекурсивно-логическое програм-\nмирование», «Искусственный интеллект». Оно никоим образом\nне претендует на полноту излагаемого материала и базируется на\nличном опыте преподавания. Пособие следует воспринимать как\nпутеводитель, и учащиеся в процессе обучения должны активно\nиспользовать литературу, на которую в тексте указаны ссылки. В\nцитируемом тексте в виде сносок автор позволяет себе высказы-\nвать свое отношение к изложенному.\nФорма тренинга, примененная в пособии, позволяет рассмат-\nривать материал в процессе монолога с читателем. Ставится\nзадача, обсуждаются возможные варианты ее решения. Затем\nрассматривается новый материал, необходимый для реализации\nвыбранного решения. Если в процессе появляется необходимость\nв изучении дополнительного материала, то параллельно основ-\nному монологу создается новый. Если читатель знаком с изла-\nгаемым материалом, то его можно пропустить и перейти далее\n(по ссылке) к рассмотрению решения задачи. Форма изложения,\nпринятая в пособии, предполагает, что материал осваивается с\nсамого начала до самого конца. То есть эту книгу будет сложно\nиспользовать как справочник.\nПрактически все разделы пособия представляют собой автор-\nскую разработку, за исключением вводной части, которая содер-\nжит компиляцию материала из различных книг и справочников.\n5 Предисловие\nВо всем тексте, по возможности, указаны ссылки на оригиналь-\nные источники информации. Автор не преследует цели коммер-\nческого использования учебного пособия. В электронной версии\nссылки на литературу в списке литературы – активные и ведут\nк найденным в Интернете электронным версиям книг. Читатель\nдолжен решать самостоятельно: скачивать их из Интернета, по-\nкупать в магазинах или искать в библиотеках.\nДанное учебное пособие является свободной книгой (так же\nкак и свободное программное обеспечение), которую можно\nпри определенных условиях читать, копировать и дополнять но-\nвым материалом. Адрес исходного кода методического пособия:\nhttps://github.com/eugeneai/ais/tree/ais-pure-math . Ис-\nходный код разрешено использовать в соответствии с лицензией\nCC BY-NC-SA 4.0 (Attribution-NonCommercial-ShareAlike 4.0 In-\nternational), которая позволяет включать материал в свои произ-\nведения (необходимо указывать автора оригинальных материа-\nлов), запрещает коммерческое использование материалов (ввиду\nналичия заимствований в первой части) и требует распростра-\nнение производных материалов производить по этой же самой\nлицензии (по указанной выше же причине). Адрес лицензии:\nhttp://creativecommons.org/licenses/by-nc-sa/4.0/ .\nВ тексте пособия использована следующая разметка:\n• моноширинным шрифтом приводятся программы, фрагменты\nпрограмм в основном тексте пособия, а также имена иден-\nтификаторов, т. е. все, что имеет какое-либо отношение к\nтексту программы;\n6 Предисловие\n• наклонным шрифтом выделяются новые термины, вводи-\nмые в текст и возникающие, например, в определениях, а\nтакже текст выделенных примеров;\n• при помощи «кавычек» выделяются метафоры, значения,\nэлементы текстов программ, цитаты, слова, использованные\nв переносном смысле, и т. д.\nАвтор пособия надеется, что материал, представленный в дан-\nной книге, будет полезным при решении практических и научных\nзадач, а также что он вызовет интерес студента к разработке про-\nграммного обеспечения в области искусственного интеллекта.\nДоцент кафедры ИТ ИМЭИ ИГУ\nканд. техн. наук Е. А. Черкашин\nDOI:10.5281/zenodo.32090\nhttp://eugeneai.github.io/ais/\nP. S. Автора искать по адресу eugeneai@icc.ru , в поле « тема »\nпросим указывать «ИИ-2014».\n7 1. Информатика и искусственный\nинтеллект\nСреди задач, которые решают современные программисты,\nвыделяются задачи создания программных систем математиче-\nского моделирования и прогнозирования, проектирования и ре-\nализации информационных систем и баз данных, системного\nпрограммного обеспечения. Все перечисленные задачи объеди-\nняет одно общее свойство – для широкого практического класса\nзадач можно построить детерминированную процедуру (напри-\nмер, алгоритм) их решения. Существует большой класс задач,\nдля которых такую процедуру построить достаточно сложно, а\nпорой и невозможно. Например, разработать игровую систему,\nспособную играть в шахматы с человеком на высоком профес-\nсиональном уровне. К таким задачам относятся также и задачи\nпоиска решения (планирование действий, или Problem Solving),\nраспознавание образов, экспертные консультации, интеллекту-\nальное управление сложными динамическими объектами и т. д.\nВ каждой такой задаче четко вырисовывается их первое общее\nсвойство – необходимость автоматизации принятия некоторо-\nго решения. В других задачах четко вырисовывается еще одно\nсвойство – обработка символьной информации. Примерами за-\nдач, обработка информации в которых основывается на преобра-\nзовании строк символов, выступают следующие задачи: автома-\nтический перевод текста с одного естественного языка на другой,\nавтоматическое доказательство теорем. В той или иной мере оба\nвыделенных свойства присутствуют в каждой из задач.\n8 1. Информатика и искусственный интеллект\nСредства искусственного интеллекта 1 , в частности логическое\nпрограммирование, позволяют представить решение таких задач,\nалгоритм, в рекурсивном виде или в виде некоторого перебор-\nного процесса. Такое представление обладает одним полезным\nсвойством – оно компактно и достаточно близко к исходной ма-\nтематической модели задачи по сравнению с изученной ранее\nпроцедурной парадигмой программирования. Программисту не\nтребуется определять все действия, необходимые для достиже-\nния результата. Как правило, достаточно рассказать транслятору,\nкакие данные есть в наличии, объяснить, как они связаны друг\nс другом и постановкой задачи. Система постарается получить\nрешение самостоятельно. Логическое программирование прежде\nвсего направлено на решение задач ИИ, поэтому в данном учеб-\nном пособии необходимо ввести читателя в базовые концепции\nИИ. Для начала рассмотрим, как можно определить, относится\nли ваша задача к задачам ИИ.\nРассмотрим задачи планирования действий. Что есть решение\nв этих задачах? Это ответ на вопрос «Какие действия необхо-\nдимо выполнить и в каком порядке их надо выполнять, чтобы\nдостичь цели из некоторого начального состояния?». Получает-\nся, что ответ на этот вопрос есть некоторая конечная последова-\nтельность действий. Эта последовательность представляется в\nпамяти компьютера в виде некоторого ряда чисел, кодирующего\nэту последовательность. Построить (найти) эту последователь-\nность, выбрать последовательность из возможных альтернатив –\nэто и есть принятие решения.\n1 В\nанглоязычной литературе данный термин называется Artifical Inelligence, AI.\n9 1. Информатика и искусственный интеллект\nЕсть еще один интересный аспект алгоритма – массовость,\nт. е. алгоритмы должны строиться для некоторого класса задач,\nа не для конкретных входных данных. Что это значит? На вход\nпрограммы, реализующей алгоритм, подаются какие-либо вход-\nные данные, задающие конкретную задачу из класса решаемых\nалгоритмом задач. Теперь представим такую ситуацию, что на\nвход алгоритма невозможно подать все необходимые данные, т. е.\nимеет место неполнота информации. Или другой вариант: имеет-\nся два эксперимента с разными результатами, но с одинаковым\nнабором исходных данных. Какие данные следует передавать на\nвход алгоритма? Этот случай связан с противоречивой инфор-\nмацией. Разрабатывая программное обеспечение, позволяющее\nфункционировать в таких условиях, приходится создавать под-\nпрограммы, принимающие решение, что следует делать. Напри-\nмер, во втором случае можно запустить алгоритм для каждого\nнабора данных и проанализировать полученные результаты. Мо-\nжет получиться так, что эти результаты не будут сильно отли-\nчаться друг от друга, а может этого не получиться. В последнем\nслучае одним из вариантов дальнейших действий является поиск\nнового атрибута (характеристики), который позволит различать\nварианты, находящиеся в противоречии.\nЗадачи, обладающие перечисленными свойствами, и мето-\nды их решения на ЭВМ в конечном счете составляют предмет\nисследования искусственного интеллекта – одного из разделов\nинформатики (Computer Science).\n10 1.1. Определения\n1.1. Определения\nВ литературе можно найти целый спектр определений тер-\nмина «искусственный интеллект», однако, насколько известно\nавторам, ни один из них не принят как стандарт.\nСреди многих точек зрения доминируют три [3]. Согласно\nпервой, исследования в области искусственного интеллекта яв-\nляются фундаментальными исследованиями, в рамках которых\nразрабатываются модели и методы решения задач, традицион-\nно считавшихся интеллектуальными и не поддававшихся ранее\nформализации и автоматизации. Согласно второй точке зрения,\nновое направление связано с новыми идеями решения задач на\nЭВМ, с разработкой принципиально иной технологии програм-\nмирования, с переходом к архитектуре ЭВМ, отвергающей клас-\nсическую архитектуру, которая восходит еще к первым ЭВМ.\nНаконец, третья точка зрения, по-видимому, наиболее прагмати-\nческая, состоит в том, что в результате работ в области искус-\nственного интеллекта рождается множество прикладных систем,\nрешающих задачи, для которых ранее создаваемые системы бы-\nли непригодны.\nДостаточно простые определения искусственного интеллек-\nта показаны в табл. 1.1 [11]. Выделяются несколько комбина-\nций двух пар ключевых терминов: «размышлять» и «вести себя»,\n«как человек» и «рационально».\nИскусственный интеллект как наука насчитывает уже около\n60 лет. Задачей этой науки является воссоздание с помощью ис-\nкусственных устройств (в основном с помощью ЭВМ) разумных\nрассуждений и действий [4].\n11 1. Информатика и искусственный интеллект\nТаблица 1.1\nНесколько определений искусственного интеллекта\nСистемы, которые размышля- Системы, которые размышля-\nют, как люди\nют рационально\nСистемы, которые ведут себя, Системы, которые ведут себя\nкак люди\nрационально\nИскусственный интеллект – раздел информатики, изучаю-\nщий методы, способы и приемы моделирования и воспроизведе-\nния с помощью ЭВМ разумной деятельности человека, связанной\nс решением задач [6].\n1.1.1. Тест Тьюринга\nВ книге [11] вводится понятие агента. Агент – субъект, на-\nходящийся в среде, имеющий цель своего существования, вза-\nимодействующий со средой или другими агентами с помощью\nрецепторов и эффекторов. Рецепторы воспринимают инфор-\nмацию о среде, а эффекторы – это способ воздействия на среду,\nкоторое меняет среду, а следовательно, и информацию о среде.\nАгентом может являться как программа, так и человек. Вводит-\nся понятие интеллектуального агента – агента, обладающего\nинтеллектом.\nАгенты взаимодействуют друг с другом. Примером такого\nвзаимодействия выступают, например, общение человека с чело-\nвеком или работа человека с компьютерной программой.\nТест Тьюринга предложен Аланом Тьюрингом (1950) и был\nразработан, чтобы представить действующее определение ин-\n12 1.1. Определения\nтеллекта [11]. Тьюринг определял интеллектное поведение как\nвозможность достижения человеческого уровня производитель-\nности во всех задачах, где возможно обмануть человека, задаю-\nщего вопросы. Грубо говоря, предложенный им тест состоял в\nследующем. Компьютеру задает вопросы человек через удален-\nное устройство. Тест считается пройденным, если человек не\nможет сказать, кто или что на другом конце устройства: компью-\nтер или человек.\nС точки зрения агентов, этот тест можно представить так: один\nинтеллектуальный агент (человек) по информационному каналу,\nне позволяющему ему использовать иную информацию, кроме от-\nветов на поставленные им вопросы, анализирует поступающую\nинформацию (ответы собеседника) от другого агента (испытуе-\nмого). Если первый агент не в силах определить, кто на другом\nконце информационного канала – человек или устройство, тогда\nсчитается, что испытуемый агент обладает интеллектуальными\nсвойствами.\n1.1.2. Задачи ИИ\nВсякая задача, для которой неизвестен алгоритм решения,\nаприорно относится к ИИ. Перечислим некоторые направления\n(задачи) ИИ [3].\nВосприятие и распознавание образов. К таким задачам от-\nносятся распознавание текста (как печатного, так и рукописного),\nкомпьютерное зрение.\n13 1. Информатика и искусственный интеллект\nАвтоматическое доказательство теорем. В этом направле-\nнии решаются задачи автоматизации математических исследова-\nний, разработки формальных (математических) методов логиче-\nского вывода для поддержки решения других задач ИИ. Это на-\nправление нашло применение в задачах верификации программ-\nного и аппаратного обеспечения.\nИгры. Автоматизация решения игровых задач, например иг-\nры в шахматы, кала́х, реверси, а также других игр.\nРешение задач (Problem Solving), планирование действий.\nВ этих задачах предполагается наличие некоторого выбора из\nвозможных путей решения, требуется найти первое, лучшее или\nоптимальное решение. Примеры: составление расписания рабо-\nты учебного учреждения, планирование действий автономного\nнеобитаемого аппарата.\nПонимание естественного языка. Как правило, системы по-\nнимания естественного языка являются составляющими инфор-\nмационных систем различного назначения: от автоматических\nсистем заказа билетов до систем ввода экспертного знания.\nЛогическое программирование. Языки и системы програм-\nмирования высокого выразительного уровня, построенные на\nоснове результатов исследования формально-логических систем,\nтеорий исчислений. Эта область ИИ носит, кроме прочего, ин-\nструментальный характер, т. е. логическое программирование\nявляется средством реализации систем ИИ.\n14 1.1. Определения\nЭкспертные системы. Экспертные системы (ЭС) позволя-\nют заменять человека-эксперта в некоторой предметной обла-\nсти программной системой, способной проводить экспертные\nконсультации пользователя. ЭС нашли широкое применение в\nиндустрии.\nИнтеллектные информационные системы. Эти cистемы\nобъединяют разнородные интеллектные системы (например, си-\nстемы речевого общения, решения задач) для организации ин-\nтеллектного доступа, обработки информации. Они, как правило,\nпредназначены для работы с конечным пользователем низкой ква-\nлификации. Пример: электронные переводчики и разговорники.\nВосприятие и усвоение знаний. Одна из задач ИИ – это при-\nобретение знаний 1 (обучение, наполнение базы знаний) от чело-\nвека или самостоятельно из среды функционирования. Системы\nусвоения знаний используются как подсистемы других интел-\nлектных систем.\nИнтеллектное управление [2]. Новое направление, появив-\nшееся на стыке ИИ и теории управления, в котором разраба-\nтываются управляющие системы, основанные на тех или иных\nметодах ИИ. В настоящее время наиболее развиты методы управ-\nления на основе нечеткой логики и искусственных нейронных\nсетей. В этом новом направлении ведутся научные разработ-\nки Института динамики систем и теории управления СО РАН\n( http://www.idstu.irk.ru ).\n1 Англ.\n– Knowledge Acquisition.\n15 1. Информатика и искусственный интеллект\nРобототехника (Robotics). Собирательное направление ис-\nследований, задачей которого является автоматизация функци-\nонирования роботов, вплоть до полной независимости их от че-\nловека.\nОпределение задач ИИ в контексте пособия.\nК сфере искус-\nственного интеллекта относятся задачи, обладающие следующи-\nми свойствами [4]:\n• в них используется информация в символьной форме: буквы,\nслова, знаки, рисунки. Это отличает область ИИ от областей,\nв которых традиционно компьютерам доверяется обработка\nданных в числовой форме 1 ;\n• в них предполагается наличие выбора; действительно, ска-\nзать, что не существует алгоритма 2 , – это значит сказать,\nпо сути дела, только то, что нужно сделать выбор между\nмногими вариантами в условиях неопределенности, и этот\nнедетерминизм, который носит фундаментальный характер,\nэта свобода действия являются существенной составляю-\nщей интеллекта.\nИзлагаемый в пособии курс подразумевает непосредственное\nизучение технических аспектов применения методов ИИ, таких\nкак применимость того или иного метода в конкретной задаче,\nреализация программных модулей конкретного метода. Поэтому\n1 Например,\nматематическое моделирование, базы данных.\nопределение алгоритма: алгоритм – это конечная последовательность дей-\n2 Интуитивное\nствий, каждое из которых выполняется за конечное время, приводящая к определенному\nрезультату.\n16 1.1. Определения\nв предлагаемом курсе мы будем использовать следующее опре-\nделение искусственного интеллекта:\nИскусственный интеллект – область информатики, в\nкоторой разрабатываются и исследуются методы по-\nстроения программных систем и решения задач, так\nили иначе связанных с принятием решения и обработ-\nкой символьной информации 1 .\n1.1.3. Данные и знания\nОдним из фундаментальных терминов ИИ является термин\nзнание. Данный термин также является сложным в смысле его\nконструктивного определения, понятного читателю. Как правило,\nавторы статей по ИИ сознательно уклоняются давать более или\nменее точные определения, предполагая, что читателю это уже\nизвестно.\nБолее формальный термин «данные» получил широкое рас-\nпространение в научно-техническом обиходе, в особенности в\nпрактике использования ЭВМ для решения самых разнообраз-\nных задач [3]. При этом вся обрабатываемая информация назы-\nвается данными: начальными, промежуточными или конечными,\nвходными или выходными. Для предложений естественного язы-\nка более привычны термин «знание» и глагол «знать». Ни у кого\nне вызывает возражений использование этого слова в предло-\nжениях вроде «Я знаю, как решить задачу» или «Я знаю, что\nвчера Петя встречался с Наташей». Сомнению может подвер-\n1 Данное\nопределение задает термин в достаточно узком смысле.\n17 1. Информатика и искусственный интеллект\nгаться лишь истинность подобных утверждений, но никак не\nвозможность сочетания слова «знать» с фрагментами предложе-\nния, обозначающими любую информацию, о которой говорится,\nчто она кому-то известна.\nВопрос о разделении информации на данные и знания возник\nпри разработке систем ИИ, характеризуемых в последнее вре-\nмя как системы, основанные на знаниях 1 . Был предложен ряд\nопределений, отражающих различные аспекты этих понятий, но\nкасающихся скорее форм (см. раздел 1.2) представления данных\nи знаний, правил их использования, чем их сути.\nДва подхода к разработке методов и средств ИИ\n«Снизу вверх». Суть подхода выражена в фразе «Давайте\nсоздадим механическое (вычислительное) устройство, похожее\nна (моделирующее) мозг человека, а затем посмотрим, как оно\nбудет решать задачи ИИ».\n«Сверху вниз». В основе этого подхода лежит разработка\nметодов моделирования процесса мышления человека (логиче-\nских выводов, логических рассуждений).\nМетоды и системы ИИ, основанные на подходе «Снизу вверх»,\nкак правило, представляют собой сложную сеть взаимосвязан-\nных, простых по сути, элементарных агентов. Эта сеть агентов\nформирует агента высокого уровня, направленного на решение\nконкретной задачи ИИ. Элементарные агенты сети вносят неболь-\n1 На\nсамом деле это определение не охватывает такую важную отрасль ИИ, как нейронные\nсети.\n18 1.1. Определения\nшой персональный вклад в решение агента высокого уровня.\nВыделяют одно из достоинств этого подхода: если задача «не\nрешается» какими-то формальными методами, то ее «хоть\nкакое-то» решение может быть получено методами «Снизу\nвверх». Как правило, схема применения описываемых методов\nи систем состоит из двух этапов: обучение на известном наборе\n«данные – решения» (данные и решения известны) и решения\nновых задач (данные известны, решения – нет).\nИзвестным недостатком, присущим методам и системам «Сни-\nзу вверх», является неопределенность характеристик с точки зре-\nния их практического применения: трудно ответить, например,\nна вопросы: «Сколько нужно агентов, чтобы решить конкретную\nзадачу? Каковы должны быть связи между агентами?». В каждом\nконкретном случае требуются эмпирические исследования («смо-\nжет – не сможет»). Типичным представителем подхода «Снизу\nвверх» являются нейронные сети.\nМоделирование логических выводов и рассуждений – основа\nподхода «Сверху вниз». В системах ИИ (агентах), основываю-\nщихся на этом подходе, как правило, четко выделяют функцио-\nнальные блоки «Хранилище базы знаний», «Машина логического\nвывода» и интерфейс «Рецептор – Блок рассуждений – Эффектор».\nВ задачу последнего блока входит преобразование информации\nв/из вид (-а), используемый (-ого) в первых двух блоках. Именно\nв этих методах и системах ИИ возникает задача представления\nзнаний в некотором формализованном виде, удобном для осу-\nществления их интерпретации и преобразований в блоке «Ма-\nшина логического вывода». Примерами систем «Сверху вниз»\n19 1. Информатика и искусственный интеллект\nвыступают язык программирования Пролог, экспертные систе-\nмы, системы автоматического логического вывода.\nИсходя из общих соображений, естественно определить дан-\nные как некоторые сведения об отдельных объектах, а знания – о\nмире в целом. В согласии с таким подходом будем считать, что:\nданные представляют информацию о существовании\nобъектов с определенными комбинациями свойств (зна-\nчений признаков), а знания – информацию о существу-\nющих в мире закономерных связях между признаками,\nзапрещающих некоторые другие сочетания свойств у\nобъектов.\nОтсюда следует, что различие между данными и знаниями\nможно сформулировать так: данные – это информация о суще-\nствовании объектов с некоторым набором свойств, а знания –\nинформация о несуществовании объектов с некоторым набором\nсвойств 1 .\nИспользуя логический формализм (см. далее) представления\nзнаний, продемонстрируем эти понятия в формализованном виде.\nПусть 𝐻(𝑥) обозначает высказывание « 𝑥 является человеком»,\nа 𝑀(𝑥) – « 𝑥 – смертен». Теперь представим данные как утвер-\nждения с кванторами существования («существует 𝑥 , 𝑥 является\nчеловеком»):\n𝐴 1 = ∃𝑥𝐻(𝑥),\n1 Вообще\nговоря, данное предложение не является определением, оно неконструктивно, т. е.\nне задает логических связей с известными объектами и терминами. В частности, термин\n«навык» тоже подходит под это же определение как нечто, отличное от «данных».\n20 1.1. Определения\nзнания – утверждения с отрицанием существования («не суще-\nствует бессмертных людей»):\n𝐴 2 = ¬∃𝑥(𝐻(𝑥)&¬𝑀(𝑥)),\nлегко преобразуемые в утверждения с квантором всеобщности\n(«все люди смертны»):\n𝐴 3 = ∀𝑥(𝐻(𝑥) → 𝑀(𝑥)).\nЗапись знаний с использованием логической связки отрицания\nперед квантором всеобщности (как в формуле 𝐴 2 ) не применя-\nется на практике. Удобней и понятней форма 𝐴 3 , т. е. форма с\nквантором всеобщности, утверждающим, что все объекты 𝑥 , об-\nладающие свойством 𝐻 , будут обладать свойством 𝑀 .\nВ формулах некоторые объекты удобно задавать именами. На-\nпример, утверждение «Сократ – человек» представляется в виде\nформулы 𝐻(𝑠) , где 𝑠 обозначает Сократа. Теперь продемонстри-\nруем процесс обработки информации с использованием форма-\nлизованного знания 𝐴 3 и исходного данного 𝐻(𝑠) :\n(𝐻(𝑠)&∀𝑥(𝐻(𝑥) → 𝑀(𝑥))) → 𝑀(𝑠).\nИз того, что Сократ – человек и что все люди смертны, следу-\nет, что Сократ тоже смертен. Доказательство «от противного»\nпредлагается построить читателю самостоятельно.\nВ конце книги [7] данные и знания (совместно с «умениями»)\nохарактеризованы следующим образом.\nДанные должны прежде всего храниться, а затем в поряд-\nке убывания приоритетов для непосредственной применимости\n21 1. Информатика и искусственный интеллект\nуспешно находиться при нужде, проверяться, поддерживаться\nв порядке и обновляться при необходимости. Таким образом,\nони хранятся неизменными, пока не будут явно обновлены, и\nпоэтому обычно внимание уделяют прежде всего сохранению,\nподдержанию их адекватности меняющемуся состоянию дел и\nцелостности при необходимых изменениях.\nЗнания должны прежде всего преобразовываться. Далее, их\nнужно хранить, как и данные, они должны быть доступными, они\nдолжны конкретизироваться применительно к данной ситуации\nи обобщаться для целого класса применений. Они, конечно же,\nдолжны при необходимости пересматриваться. И, наконец, они\nдолжны переводиться с одного языка на другой.\nУмения прежде всего применяются. Помимо этого, они пре-\nобразуются для обеспечения гибкости или приспособления к\nизменившимся условиям. Далее они обобщаются и пересматри-\nваются.\nВ процессе исследований природных явлений ученые сначала\nнакапливают информацию в виде данных, выделяя объекты и\nвыявляя и измеряя их свойства. Знания – результат обработки\nданных и их обобщения. Классическим примером данных слу-\nжат таблицы движения планет по небесному своду Тихо Браге,\nпримером знаний – выведенные из них законы Иоганна Кеплера\nи затем, как обобщение результатов Кеплера, закон всемирного\nтяготения Исаака Ньютона.\n22 1.2. Формализмы представления знаний\n1.2. Формализмы представления знаний\nВ интеллектуальных системах используются различные фор-\nмализмы 1 представления знаний – логический, сетевой, продук-\nционный и фреймовый.\nЛогический формализм традиционно применяется для реа-\nлизации систем автоматического доказательства теорем, логи-\nческих языков и сред программирования и экспертных систем.\nСетевой формализм удобен в решении задач поддержки диало-\nга с пользователем на естественном языке, формализации кон-\nцептуального уровня предметной области (онтологий). Сетевой\nформализм совместно с логическим формализмом в настоящее\nвремя используется для верификации онтологий и построения\nлогического вывода новых знаний и данных из указанного кон-\nцептуального уровня.\nОсновная область применения продукционного формализма –\nописание баз знаний экспертных систем, систем поддержки при-\nнятия решений. Знания в продукционной модели представляются\nв виде утверждений «Если …, то …», база знаний – это множе-\nство таких утверждений. Отдельные утверждения в базе знаний\nможно удалять и добавлять новые, и если множество утвержде-\nний достаточно большое, то небольшие его изменения не влияют\nна общую работоспособность программной системы. То есть\nпродукционный формализм удобен, если необходимо проводить\nэксперименты с логическим описанием предметной области си-\nстемы, основанной на знаниях.\n1 Способы\nформального описания.\n23 1. Информатика и искусственный интеллект\nФреймовый формализм в некоторой степени схож с объектами\nв прототипных объектноориентированных языках программи-\nрования, например JavaScript, Self. В основе формализма лежит\nидея декомпозиции предметной области на отдельные концеп-\nты и объекты, объединенные в иерархию, представления их в\nвиде набора атрибутов. Каждый концепт и объект является на-\nбором слотов. Слоты состоят из описания и значения, значение\nдолжно соответствовать описанию или отсутствовать. Решение\nзадачи распознавания на фреймовом формализме заключается в\nвыявлении фрейма, лучшим образом соответствующего распо-\nзнаваемому объекту.\nМы не будем далее подробно формально описывать формализ-\nмы в этом учебном пособии, познакомимся с их особенностями\nпо мере необходимости и только в нужном объеме. Считается,\nчто все формализмы эквивалентны, т. е. знания из одного фор-\nмализма интерпретируются полноценно в другом формализме\n(тезис Черча).\n24 2. Логические модели и логическое\nпрограммирование\nСамой известной системой ИИ, использующей логический\nформализм, является язык логического программирования Pro-\nlog (Пролог) [1], который будет предметом нашего дальнейшего\nизучения. Название «Пролог» образовано из слияния терминов:\n«ПРОграммирование в терминах ЛОГики». Пролог относится\nк классу языков, называемых сентенциальными. Классические\nреализации Пролога используются в вузах мира для обучения\nстудентов методам автоматизации рассуждений. Специальные\nверсии этого языка, например Prolog-III, являются дорогими ком-\nмерческими продуктами и предназначаются для решения комби-\nнаторных задач с удовлетворением ограничений. К таким задачам\nотносятся задачи раскроя материала, составление расписаний,\nзадачи проектирования сетей изготовления и распространения\nпродукции (задачи логистики).\nПрограмма на языке Prolog представляет собой набор ло-\nгических высказываний (утверждений), называемых фразами\n(clauses):\nh(s). % Сократ - человек.\nm(X) :- h(X). % Все люди смертны.\nКаждая фраза завершается точкой 1 « . ». В приведенном приме-\nре первое высказывание h(s) является фактом, которому интер-\nпретатор языка «верит» по определению. Второе высказывание\n1 Со\nзнака процента « % » начинается комментарий к тексту программы.\n25 2. Логические модели и логическое программирование\n(«Все люди смертны») – это правило. Правило состоит из головы\nm(X) и тела h(X) . Знак « :- » обозначает логическую связку « ← »\nи читается как «если». Правило связывает истинность высказы-\nвания, представленного в теле, с истинностью высказывания в\nголове: высказывание в голове правила истинно, если истинно\nвысказывание в теле правила.\nИдентификаторы в Prolog бывают двух видов. С маленькой\nбуквы 1 начинаются идентификаторы, обозначающие что-то кон-\nкретное. В нашем примере идентификатор s обозначает Сократа,\nт. е. конкретный объект; h и m обозначают свойства аргумента\n«быть человеком» и «быть смертным» соответственно. Эти обо-\nзначения не меняются в процессе исполнения программы и в язы-\nке Prolog называются атомами 2 . Атомы также можно задавать\nпри помощи строк в одинарных кавычках, например ’Россий-\nская Федерация’ . Такая форма записи позволяет использовать в\nкачестве атомов любые строки.\nГолова правила и атомарные высказывания, составляющие\nтело правила, строятся при помощи идентификаторов, обозна-\nчающих высказывания и называемых предикатами 3 . Высказы-\nвания m(s) и h(s) построены на основе предикатов 𝑚(𝑥) и ℎ(𝑥) .\n1 Разные\nреализации интерпретаторов задают различные ограничения на алфавит букв, из ко-\nторых можно формировать идентификаторы. Одни интерпретаторы позволяют использовать\nтолько буквы латинского алфавита, другие – всю таблицу Unicode.\nматематической логике атомами обозначают неделимые высказывания, т. е. конструкции\n2 В\nвида 𝑚(𝑥) , ℎ(𝑥) . Это, конечно, приводит к некоторой путанице.\n(от лат. praedicatum – сказуемое) в узком смысле – то же, что термин «свойство»;\nв широком смысле – отношение, т. е. общее свойство нескольких предметов. В логике –\n3 Предика т\nпропозициональная функция, т. е. выражение с неопределенными терминами (переменны-\nми), при выборе конкретных значений для этих терминов преобразующееся в осмысленное\n(истинное или ложное) высказывание.\n26 2. Логические модели и логическое программирование\nВ Prolog при обозначении предикатов переменные 𝑥 , 𝑦 и т. п. не\nиспользуются, указывается только количество аргументов при\nпомощи символа « / » (слеш): h/1 , m/1 .\nИдентификаторы, начинающиеся с большой (прописной) бук-\nвы, – переменные. Значения переменных в общем случае меня-\nются: в переменную в процессе исполнения программы подстав-\nляются объекты, структуры и другие переменные. В нашей про-\nграмме в правиле используется одна переменная X . Существует\nспециальный случай – переменная « _ » (подчерк), при помощи\nкоторой обозначают никому не нужные значения, мы их будем\nиспользовать позже. С подчерка также начинаются названия пе-\nременных, например _language .\nПриводимые в методическом пособии примеры демонстриру-\nются на платформе интерпретатора SWI-Prolog [16]. Интерпрета-\nтор доступен в Интернете и является полностью свободным. Если\nинтересно, то можно загрузить и изучить его исходный код. До-\nмашняя страница находится по адресу: http://www.swi-prolog.\norg/ . На одной из страниц сайта есть ссылка на версию SWISH-\nинтерпретатора, функционирующую онлайн. Кроме того, на сай-\nте размещена ссылка на обучающий материал по тематике логиче-\nского программирования: http://www.learnprolognow.org/ .\nЧтобы запустить программу, необходимо ее загрузить в ин-\nтерпретатор и сделать запрос:\n?- [’socrates.pl’].\n% Загрузка программы\n% socrates.pl compiled 0.00 sec, 1 clauses\n?- m(s).\n% Запрос\ntrue.\n?- _\n27 2. Логические модели и логическое программирование\nВ приведенном примере « ?- » обозначает приглашение к вводу\nпользователем запроса. Запросы – это тоже фразы языка, по-\nэтому тоже заканчиваются точкой. Запрос специального вида\n[’socrates.pl’] загружает программу из файла socrates.pl ,\nкоторый должен находиться в той же папке, где был запущен ин-\nтерпретатор. Фраза m(s) – это запрос к интерпретатору: «Правда\nли, что Сократ смертен?» Ответ true или yes является резуль-\nтатом рассуждений интерпретатора над запросом, результатом\nдоказательства его истинности. В последней строке примера под-\nчерком показан курсор, т. е. интерпретатор находится в режиме\nожидания ввода нового запроса. Запрос загрузки программы и\nпоследнюю строку с курсором далее не будем приводить в коде\nпрограммы.\nИнтерпретатор Prolog не может вывести истинность некото-\nрого запроса в двух случаях:\n• в процессе поиска логического вывода невозможно найти\nподходящий факт, от которого зависит истинность нужного\nтела правила;\n• логический вывод уходит в бесконечную рекурсию.\nВ первом случае Prolog выдает false или no и считает, что утвер-\nждение запроса ложно. Во втором случае необходимо прерывать\nработу интерпретатора при помощи комбинации клавиш\nили\nCtrl-Break\nCtrl-C\nв Windows-версии интерпретатора.\nПроцесс логического вывода запроса отслеживается средства-\nми трассировки, встроенными в интерпретатор. Рассмотрим трас-\nсировку исполнения запроса к нашей программе:\n28 2. Логические модели и логическое программирование\n?- trace.\n% Включить трассировку.\ntrue.\n[trace]\n?- m(s).\n% Запрос\nCall: (6) m(s) ? % Нажать Enter.\nCall: (7) h(s) ? % Enter\nExit: (7) h(s) ? % Enter\nExit: (6) m(s) ? % Enter\ntrue.\n[trace]\n?- nodebug. % Отключить трассировку.\ntrue.\nПредикаты trace/0 , notrace/0 , debug/0 и nodebug/0 управ-\nляют процессом трассировки и отладки. Текущий режим интер-\nпретатора отображается строкой [trace] ?- . В режиме трасси-\nровки программа выполняется пошагово. Каждому шагу соот-\nветствует одна строка трассировки. В строке слова Call: и Exit:\nобозначают команды, выполняемые интерпретатором. Коман-\nда Call: показывает, истинность какого запроса (подзапроса)\nтребуется доказать на очередном шаге; Exit: показывает, что\nсоответствующий запрос успешно доказан.\nПриведенный пример – это далеко не полный перечень воз-\nможностей языка программирования Prolog. Остальные его свой-\nства будем рассматривать по мере необходимости при решении\nконкретных задач. Хорошим толковым учебником по языку явля-\nется книга профессора Люблянского университета Ивана Брат-\nко [1]. Следующий абзац посвящен вопросам редактирования и\nзагрузки программы. Если вы уже умеете это делать, то перехо-\n29 2. Логические модели и логическое программирование\nдите сразу на стр. 32. Далее будем обозначать такие переходы\nследующим образом: ↪ 32.\nРедактирование и загрузка программы.\nМногие ISO-совме-\nстимые реализации интерпретатора языка Prolog имеют встро-\nенные графические оконные интерфейсы. При помощи этих\nсредств можно редактировать и загружать программы, используя\nманипулятор мышь. В применяемом в данном пособии интерпре-\nтаторе SWI-Prolog также есть эти средства. В версии Windows\nредактирование программ Пролога доступно через меню оконно-\nго приложения. Встроенный редактор представляет собой упро-\nщенную реализацию системы EMACS. Редактор вызывается из\nкомандной строки интерпретатора запуском предиката emacs , в\nтом числе и в реализации Linux.\nВ классических реализациях языка Пролог введение спис-\nка утверждений в Пролог-систему осуществляется при помощи\nвстроенного предиката consult/1 . Единственным аргументом\nэтого предиката consult/1 является атом, который интерпрети-\nруется системой как имя файла, содержащего текст программы\nна Прологе. Файл открывается, и его содержимое записывается 1\nв базу знаний. Если в файле встречаются управляющие коман-\nды, они сразу же выполняются. Возможен случай, когда файл не\nсодержит ничего, кроме управляющих команд, например для за-\nгрузки других файлов. Для ускорения набора команды загрузки\n1 Фактически производится добавление новых знаний и фактов из загружаемого файла. Если в\nфайле содержатся определения предикатов, которые уже имеются в рабочей памяти системы,\nто происходит обновление этих предикатов. Это может стать причиной неработоспособности\nпрограммы. Рекомендуется иногда выходить из интерпретатора и очищать рабочую память.\n30 2. Логические модели и логическое программирование\nпользователи Пролога изобрели для себя следующую конструк-\nцию, являющуюся синонимом предикату consult/1 :\n?- [’имя файла.pl’].\nРаботая с вышеупомянутым редактором, программу можно\nзагрузить прямо из его окна при помощи комбинации клавиш\nCtrl-c\n,\nCtrl-b\n(Consult Buffer). Выход из редактора и закрытие его\nокна осуществляется комбинацией\nемого буфера –\nCtrl-x\n,\nCtrl-s\nCtrl-x\n,\nCtrl-c\n, запись редактиру-\n.\n31 3. Планирование действий\nРассмотрим задачу поиска выхода из лабиринта, точнее за-\nдачу прокладки пути между двумя разными комнатами в лаби-\nринте. В качестве примера будем использовать карту лабиринта,\nизображенную на рис. 3.1, a.\na)\n1/3 2/3 3/3 a d h\n1/2 2/2 3/2 b e i\n1/1 2/1 3/1 c f g\nb)\nc)\nРис. 3.1. Лабиринт\nФормализуем задачу. Сначала каждую комнату каким-нибудь\nобразом обозначим. Первый вариант обозначения состоит в ис-\nпользовании двоек ⟨𝑥, 𝑦⟩ , 𝑥 и 𝑦 – координаты комнаты (рис. 3.1, b).\nВ Prolog двойки удобно обозначать в форме X/Y , так как запятая\nиспользуется в перечислении аргументов предикатов. Если факт\nналичия проема или двери (перехода) между двумя комнатами\nA и B обозначить предикатом e(A,B) , то следующая программа,\nнабор фактов, будет представлять структуру нашего лабиринта:\ne(1/3,1/2). e(1/2,1/1). e(1/1,2/1).\ne(2/1,2/2). e(2/2,2/3). e(2/3,3/3).\ne(2/1,3/1). e(3/1,3/2). e(3/2,3/3).\nДругим вариантом обозначения комнат является использова-\nние имен («гостиная», «логово дракона») или просто букв a, b,\n32 3. Планирование действий\nc и т. д. (рис. 3.1, c). Тогда набор фактов приобретет более ла-\nконичный вид, но в этом случае теряется часть информации об\nотносительном расположении комнат. Хорошо, что она нам не\nпонадобится.\ne(a,b). e(b,c). e(c,f ).\ne(f ,e). e(e,d). e(d,h).\ne(f ,g). e(g,i). e(i,h).\nТеперь надо системе Prolog объяснить, как прокладывать пути\nмежду комнатами, точнее что такое путь между двумя комнатами.\n1. Между двумя комнатами существует путь, если между эти-\nми комнатами есть переход.\n2. Между двумя комнатами A и B существует путь, если из\nкомнаты A можно перейти в еще одну комнату C , а из нее\nпостроить путь в B .\nЗапишем это на языке Prolog, дополнив одну из предыдущих\nформализаций лабиринта:\npath(A,B) :- e(A,B).\npath(A,B) :- e(A,C), path(C,B).\nЗапрос, соответствующий решению задачи прокладки пути,\nбудет следующим:\n?- path(a,h).\ntrue ;\ntrue ;\nfalse.\n33 3. Планирование действий\nПрограмма выдала два положительных ответа и один false .\nСтруктура нашего лабиринта допускает наличие двух путей от\nвхода к выходу. На каждый положительный ответ интерпретатор\nожидает команды пользователя: требуется ли ему еще один от-\nвет (\n;\n,\nEnter\n) или нет ( Enter ). В системе gprolog (GNU Prolog)\n[13] есть вариант\na\n, который выдает на экран все решения. Ис-\nпользовать его надо с осторожностью, так как программа может\nпорождать бесконечное количество вариантов решения задачи.\nВ программе появились новые синтаксические конструкции.\nИстинность высказывания в голове второго правила теперь за-\nвисит от двух предикатов e/2 и path/2 , соединенных запятой\n« , », которая обозначает конъюнкцию: надо, чтобы одновремен-\nно и e(A,C) , и path(C,B) были истинны. Далее, истинность\npath(a,h) выводится из двух разных правил. Пролог просмат-\nривает правила последовательно сверху вниз справа налево по\nтексту программы. Сначала будет осуществлена попытка выве-\nсти path(a,h) из первого короткого правила, что невозможно,\nтак как e(a,h) отсутствует в наборе фактов. Затем Prolog попы-\nтается вывести path(a,h) из второго правила, что приведет к\nнеобходимости решать две связанные подзадачи, достигать две\nподцели, исполнять два подзапроса: e(a,C) и path(C,h) . Задача\ne(a,C) решается, если C = b , и тогда остается решить подзада-\nчу path(C,h) при C = b , т. е. path(b,h) . Подзапрос path(b,h)\nдоказывается аналогично запросу path(a,h) : интерпретатор ре-\nкурсивно строит решение задачи.\nРассмотрим трассировку задачи path(a,c) , решаемой за два\nперехода:\n34 3. Планирование действий\n?- trace,path(a,c).\nCall: (7) path(a, c) ?\nCall: (8) e(a, c) ?\nFail: (8) e(a, c) ? % (1)\nRedo: (7) path(a, c) ? % (2)\nCall: (8) e(a, _G1450) ? % (3)\nExit: (8) e(a, b) ?\nCall: (8) path(b, c) ?\nCall: (9) e(b, c) ?\nExit: (9) e(b, c) ?\nExit: (8) path(b, c) ?\nExit: (7) path(a, c) ?\ntrue ;\n% (4)\nRedo: (8) path(b, c) ?\nCall: (9) e(b, _G1450) ?\nExit: (9) e(b, c) ?\nCall: (9) path(c, c) ?\nCall: (10) e(c, c) ?\nFail: (10) e(c, c) ?\nRedo: (9) path(c, c) ?\n% (5)\n. . . . .\nВ этом примере появились две новые команды Redo: и Fail: ,\nсоответственно обозначающие попытку вывести истинность за-\nпроса из следующего по списку правила и неудачное завершение\nпоиска доказательства запроса. В точке (1) Fail: показывает, что\nутверждение e(a,c) отсутствует в списке фактов. Это приводит\nк необходимости (2) перейти к следующему правилу Redo: . Зада-\nча e(a, _G1450) то же самое, что и e(a,C) , только переменная\nC переименована в _G1450 : каждый «запуск» правила требует\nразыменования используемых в нем переменных. В строке (4)\n35 3. Планирование действий\nProlog выдает первый положительный ответ, а пользователь про-\nсит предоставить еще один. Далее происходит достаточно длин-\nный перебор вариантов переменной _G1450 , который не приво-\nдит к новому решению, и интерпретатор выдает false .\nСпециальные запросы. В английском языке выделяются пять\nвидов вопросов: общие (Do You …?), разделительные (You are\n…, ain’t You?), специальные (What do You do?), к подлежащему\n(Who is …?) и «или»-вопрос (Do you like coffe or tea?). Первые\nдва класса вопросов в Прологе представляются запросами, где в\nпараметрах не используются переменные, например path(a,h)\nи e(a,b) . Специальные вопросы и вопросы к подлежащему, по-\nмимо ответа на вопрос «Так это или нет?», нацелены на полу-\nчение дополнительной информации: «Кто?», «Когда?» и т. д. В\nПрологе такие вопросы формулируются в виде запросов с ис-\nпользованием переменных:\n?- path(a,X).\nX = b ;\nX = c ;\nX = f ;\nX = e ;\nX = g ;\n. . . .\nfalse.\nЗапрос соответствует вопросу «Куда можно попасть, войдя в\nлабиринт?». Дополнительная информация, получаемая пользова-\nтелем, – значения переменной X , при которых запрос, ограниче-\n36 3.1. Списки\nние на значение X , истинен. «Или»-вопросы в Prolog задавать и\nнеестественно, и не принято ;-) .\nПрограмма работает правильно, но нам мало, чтобы програм-\nма просто показывала, существует ли путь между двумя комната-\nми лабиринта. Хотелось бы, чтобы программа также показывала\nсам путь. Для того чтобы представить путь как последователь-\nность комнат лабиринта, нужно к нашим знаниям добавить еще\nодну структуру данных – список. ↪ 39\n3.1. Списки\nЗадачи, связанные с обработкой списков, на практике встреча-\nются очень часто. Скажем, нам понадобилось составить список\nстудентов, находящихся в аудитории. В Prolog список определяет-\nся как последовательность термов 1 , заключенных в квадратные\nскобки. Приведем примеры списков Пролога:\n[jack, john, fred, jill, john]\n[name(john, smith), age(jack, 24), X]\n[Х, У, date(12, january, 1986), Х]\n[]\nЗапись специального вида [H | T] определяет новый список,\nгде Н – первый (левый) элемент нового списка, а Т – его остальные\nэлементы. Говорят, что Н – голова, а Т – хвост списка [H | T] .\n1 Терм – структура, обозначающая объект [8]. Терм обобщает понятия константы, переменной\nи функции. Например, высказывание h(wife(s)) содержит терм wife(s) , обозначающий\nжену Сократа.\n37 3. Планирование действий\nНа запрос\n?- L=[a | [b, c, d]].\nбудет получен ответ\nL=[a, b, c, d],\nа на запрос\n?- T=[a, b, c, d], L=[2 | T].\nполучим ответ\nT=[a, b, c, d], L=[2, a, b, c, d].\nЗапись [Н | Т] используется и в обратную сторону, для того\nчтобы определить голову и хвост списка. Так, запрос\n[H | T]=[a, b, c].\nдает ответ\nH = а, T = [b, c].\nЗаметим, что употребление только имен переменных Н и Т\nнеобязательно. Кроме записи вида [H | T] , для выборки термов\nиспользуются переменные. Запрос\n?- [a, X, Y]=[a, b, c].\nопределит значения\nX=b, Y=c,\n38 3.1. Списки\nзапрос\n?- [person(Х) | Т]=[person(john), а, b].\nзначения\nХ=john, Т=[а, b].\nМожно отделять в голове списка несколько элементов, соот-\nветствующая запись выглядит так: L=[H1, H2, H3 | T] . Пустой\nсписок задается так: « [] ».\nВозвращаемся к лабиринту. Далее будем использовать спис-\nки для хранения пути в лабиринте. Для этого введем третий па-\nраметр в предикат path/2 :\npath(A,B, [A-B]) :- e(A,B).\npath(A,B, [A-C|T]) :- e(A,C), path(C,B,T).\nНовые правила можно добавлять к предыдущей программе,\nтак как Prolog воспринимает одноименные предикаты с разным\nколичеством аргументов как самостоятельные. Предикаты path/2\nи path/3 формируют в данной программе свои независимые мно-\nжества правил. Выполним запрос на поиск путей, соединяющих\nвход и выход лабиринта:\n?- path(a,h,L).\nL = [a-b, b-c, c-f, f-e, e-d, d-h] ;\nL = [a-b, b-c, c-f, f-g, g-i, i-h] ;\nfalse.\n39 3. Планирование действий\nРезультат совпадает с ожидаемым (рис. 3.1, a) и представля-\nется списком переходов, формирующих путь. Каждый переход\nобозначен структурой вида A-B , где A и B – вершины графа струк-\nтуры лабиринта, соединенные дугой. Можно представить резуль-\nтат просто списком вершин:\npath2(A,B, [A,B]) :- e(A,B).\npath2(A,B, [A|T]) :- e(A,C), path2(C,B,T).\nВыполним запрос к новому предикату path2/3 :\n?- path2(a,h,L).\nL = [a, b, c, f, e, d, h] ;\nL = [a, b, c, f, g, i, h] ;\nfalse.\nКоллекционирование решений.\nЕсли есть необходимость со-\nбрать коллекцию всех решений, обладающих некоторым свой-\nством, используются предикаты bagof/3 , setof/3 и findall/3 .\nСпецификации интерфейсов этих предикатов схожи, рассмотрим\nих, как обычно, на примере:\n?- findall(X, path2(a,h,X), L).\nL = [[a, b, c, f, e, d, h], [a, b, c, f, g, i, h]].\nПредикат формирует список L путей-решений, т. е. список L таких\nX , что справедлив запрос path2(a,h,X) . Предикат findall/3 ис-\nтинен всегда, даже если нет ни одного X , такого, что path2(a,h,X)\nистинен. В последнем случае findall/3 выдает L=[] (пустой\nсписок), а вот bagof/3 и setof/3 потерпят неудачу (будут лож-\nными). Предикат setof/3 отличается от других еще и тем, что\nиз выходного списка будут удалены повторения.\n40 3.2. Алгоритмы планирования действий\n3.2. Алгоритмы планирования действий\nЗадача поиска пути в лабиринте – простейший пример класса\nзадач планирования действий. В общих словах задача относится\nк этому классу, если выполняются следующие условия:\n1) выделяется не обязательно конечный набор допустимых\nсостояний, т. е. состояний, не противоречащих природе и\nусловиям задачи;\n2) состояния соединяются переходами (не обязательно двуна-\nправленными). Эти переходы задаются набором правил, не\nпротиворечащих условиям задачи;\n3) задается логическое условие 𝑃(𝑥) , распознающее целевые\nсостояния 𝑥 ;\n4) среди допустимых состояний выделяется одно, в котором\nсистема находится в начальный момент, т. е. исходное со-\nстояние.\nРешением задачи планирования действий является построение\nпоследовательности логически связанных действий, которые\nнеобходимо выполнить, чтобы перевести систему из начального\nсостояния в одно из целевых.\nМатематическая структура, позволяющая формализовать этот\nкласс задач, строится на основе графа, называемого графом про-\nстранства состояний (State Space Graph):\n𝐺 = ⟨𝑉, 𝐸, 𝑃(𝑥), 𝑠⟩,\n41 3. Планирование действий\nгде 𝑉 – множество допустимых состояний (вершины графа), 𝐸 –\nпереходы (дуги графа, соединяющие вершины), а 𝑠 – начальное\nсостояние (стартовая вершина графа). В такой формализации ре-\nшением задачи планирования действий является путь, соединя-\nющий исходное состояние в один из целевых. При этом, как пра-\nвило, интересует не просто поиск решения, а поиск лучшего или\nоптимального решения, характеризующегося, например, мини-\nмальным количеством переходов между смежными вершинами.\nАлгоритмы поиска пути в графе с заданными свойствами опре-\nделяются стратегиями перебора неизвестных вершин, видимых\nиз области графа с уже известными вершинами (рис. 3.2, a).\na\nb\na\n𝐷\nb\ne\nd\nj\nk\nf\nr\nq\nn\np\na)\nj\nk\nf\nl\nr\nq\np\nb)\ng\nh\nj\nk\nf\nl\nn\ni\nc\ng\nh\ne\nd\ni\nc\ng\nh\nb\ne\nd\ni\nc\na\nl\nr\nq\nn\np\nc)\nРис. 3.2. Стратегии перебора вершин\nОбласть 𝐷 графа пространства состояний (ГПС) содержит\nвершины, которые к какому-то моменту уже были исследованы\nи информация о которых сохранена в оперативной памяти. Из\nэтой области видны вершины 𝑓 , ℎ , 𝑔 и 𝑖 . Стратегия перебора\nопределяет, какую из этих четырех вершин надо исследовать на\nочередном шаге. Выделим несколько основных стратегий:\n1) случайный выбор вершины;\n2) выбор вершины, максимально удаленной от стартового узла;\n42 3.2. Алгоритмы планирования действий\n3) выбор вершины, ближайшей к стартовому узлу.\nСамой простой процедурой поиска решения в ГПС есть слу-\nчайный перебор. Начиная со стартовой вершины, всякий раз\nпереходим в одну из смежных вершин и проверяем, не являет-\nся ли она целевой. Если она таковой не является, то повторяем\nпроцедуру. Очевидно, что такой дезорганизованный процесс не\nдает гарантии, что за приемлемое время будет получен приемле-\nмый результат: в связном ГПС он находит решение (останавли-\nвается) в общем случае в потенциальной бесконечности. Тем не\nменее такая процедура (а не алгоритм) очень легко реализуема\nпрограммно.\n3.2.1. Поиск в глубину\nВторая стратегия реализуется в алгоритмах поиска в глубину\n(depth-first search) (рис. 3.2, b). Примером такого поиска выступа-\nет рассмотренная ранее программа прокладки пути в лабиринте.\nПредставим ее еще раз, только в более общем виде:\ndfs(V,[]):- p(V).\n% depth-first search\ndfs(V,[V-N|T]):- \\+ p(V), after(V,N), dfs(N,T).\np(h).\nafter(X,Y):- e(X,Y); e(Y,X).\nЗапрос к программе – неотъемлемая часть задачи:\n?- dfs(a, S).\nS = [a-b, b-c, c-f, f-e, e-d, d-h] ;\nS = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-h] ;\nS = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-e, ...]\n43 3. Планирование действий\nГПС задан переходами after(X,Y) , где X и Y – допустимые\nсостояния. Множество допустимых состояний не задано в явном\nвиде, оно порождается предикатом after по мере необходимости.\nУсловие распознавания целевого состояния – p(h) . Начальное\nсостояние указано в запросе первым аргументом: dfs(a, S). В\nпрограмме использованы две новые синтаксические конструк-\nции: « \\+ » – логическая связка отрицания « ¬ »; и « ; » – логическая\nсвязка « ∨ » («или»). Применение логической связки «или» позво-\nляет в некоторых случаях сокращать текст программы за счет объ-\nединения нескольких правил с одним и тем же заголовком в одно.\nРезультат запуска программы показывает, что количество по-\nрождаемых путей для нашего двунаправленного графа потенци-\nально бесконечно. Действительно, если ГПС содержит циклы, то\nпоиск в глубину может «зацикливаться», т. е. соответствующий\nалгоритм неполон даже на конечных ГПС. Но все же у поиска в\nглубину есть два замечательных свойства: а) алгоритм прост в\nреализации, что видно из предыдущего примера; б) для хране-\nния состояния перебора, границы подграфа 𝐷 , достаточно списка\nвершин, соединяющих стартовую вершину с текущей, т. е. опера-\nтивная память компьютера используется достаточно эффективно.\nТекст программы процедуры поиска в глубину, реализованной на\nязыках общего назначения, также является лаконичным. В каче-\nстве хранилища состояния перебора, как правило, используется\nстек, организуемый непосредственно операционной системой:\n// Файл dfc.c. Компиляция: gcc -o dfs dfs.c\n#include ”stdio.h”\nint after[9][9]={\n44\n// (1) 3.2. Алгоритмы планирования действий\n// a b c d e f h i g\n{0,1,0,0,0,0,0,0,0}, // a\n{1,0,1,0,0,0,0,0,0}, // b\n{0,1,0,0,0,1,0,0,0}, // c\n{0,0,0,0,1,0,1,0,0}, // d\n{0,0,0,1,0,1,0,0,0}, // e\n{0,0,1,0,1,0,0,0,1}, // f\n{0,0,0,1,0,0,0,1,0}, // h\n{0,0,0,0,0,0,1,0,1}, // i\n{0,0,0,0,0,1,0,1,0}};// g\nint dfs(int x) {\nint y=0;\nif (x==6) { // h==6\n// (2)\nreturn 1;\n} else {\nfor (y=0;y<=9;y++) { // (3)\nif (after[x][y]) { // (4)\nif (dfs(y)) { // (5)\nprintf (”%i-%i\\n”,x,y);\nbreak;\n}}}}} // плохой стиль! Сэкономим пару строк в пособии.\nint main(int argc, char ** argv) {\nif (dfs(0)) return 0; // a==0\n(6)\nprintf (”Нет решений\\n”);\nreturn 1;\n}\nВ приведенном примере лабиринт представлен в виде матри-\nцы смежности (1), перебор дочерних вершин реализован в цикле\n(3–5) по переменной y . Функция dfs возвращает «истину» 1 , ес-\nли решение найдено (2) и часть пути из текущей вершины x до\nцелевой уже выведена на экран. Начальная вершина указывает-\n45 3. Планирование действий\nся при первом вызове dfs (6). Программа лаконичная 1 , только\nона не останавливается – «зацикливается», бесконечно переме-\nщаясь между вершинами a (0) и b (1) . Пример на языке Pro-\nlog сначала рассматривает все переходы «вперед», только потом\nвводит в рассмотрение переходы в обратном направлении. Эта\nособенность реализации программы и структура лабиринта поз-\nволяет-таки находить первое решение. Несмотря на это, будем\nпо-прежнему считать и эту реализацию «ненадежной».\nОграничение по глубине. Самый простой способ решения\nпроблемы «зацикливания» – это ввести ограничение по глубине\nпоиска. Всякий раз, когда алгоритм входит в рекурсию, будем\nотнимать единицу от специальной переменной. Если значение\nэтой переменной станет равным нулю и решение не будет найде-\nно, то вернуть «ложь» 0 . Рассмотрим модификацию программы\nна языке Prolog, а совершенствование C-программы оставляем в\nкачестве простого упражнения:\ndfsl(V,[],_):-p(V),!.\n% limited depth-first search\ndfsl(V,[V-N|T],D):- D>0, after(V,N),\nD1 is D-1, dfsl(N,T,D1).\nНовый предикат dfsl по сравнению с dfs содержит третий\nаргумент, переменную – счетчик глубины входа в рекурсию. В\nпервом правиле счетчик не используется, так как там распозна-\nется решение. Во втором правиле сначала выполняется проверка\n1 Программа\nна языке Prolog занимает значительно меньше места, чем программа на языке C.\nЭто в основном связано с тем, что Prolog-интерпретатор представляет сам по себе механизм\nпоиска решения «в глубину», а в C-программе его надо реализовать.\n46 3.2. Алгоритмы планирования действий\nусловия, что глубина допустима D>0 , затем рассматривается до-\nчерняя вершина, конструкция D1 is D-1 вычисляет арифмети-\nческое выражение D-1 и связывает результат с новой переменной\nD1 . В конце правила осуществляется вход в рекурсию с новым\nзначением глубины.\nПервое правило использует анонимную переменную « _ », она\nнужна здесь, чтобы «занимать место» третьего неиспользуемого\nаргумента, ее значение нам не важно. Во втором правиле убра-\nна проверка \\+p(V) , в ней нет особого смысла: решающие пути,\nнеоднократно попадающие в целевые вершины, остаются реша-\nющими. Приведем пример работы программы:\n?- dfsl(a, L, 8).\nL = [a-b, b-c, c-f, f-e, e-d, d-h] ;\nL = [a-b, b-c, c-f, f-e, e-d, d-e, e-d, d-h] ;\nL = [a-b, b-c, c-f, f-e, e-f, f-e, e-d, d-h] ;\nL = [a-b, b-c, c-f, f-e, e-f, f-g, g-i, i-h]\nВидно, что результат программы немного отличается от преды-\nдущего. Дальнейшим совершенствованием подхода является\nуправление ограничением по глубине. Сначала необходимо по-\nпробовать найти решения длиной в один шаг. Если попытка по-\nтерпела неудачу, перейти к решениями длиной в два шага, если\nопять неудача, то перейти к решениям, состоящим из трех шагов\nи т. д. Такой алгоритм имеет специальное название IDA (Itera-\ntive Deeping Algorithm). Алгоритм обладает важным очевидным\nсвойством: первое найденное решение является оптимальным.\nРеализацию этого алгоритма оставляем читателю.\n47 3. Планирование действий\nРаспознавание циклов. Другим популярным подходом к со-\nвершенствованию алгоритмов поиска решения в ГПС, основан-\nных на стратегии «в глубину», является распознавание циклов.\nДля реализации распознавания необходимо хранить перечень\nпройденных вершин. Как было сказано выше, этот перечень, путь\nиз стартовой вершины в текущую, сохраняется в стеке. Но ни\nв Prolog, ни в С к этому списку нет прямого доступа, к сожале-\nнию. Поэтому будем «тащить» третий аргумент в спецификации\nпроцедуры поиска, указывающий на этот путь:\ndfsr(V,[],_):-p(V). % dfs with recognition\ndfsr(V,[V-N|T],Q):- after(V,N), \\+ member(N,Q),\ndfsr(N,T, [N|Q]).\nБиблиотечный предикат member(X,L) истинный, если X явля-\nется элементом списка L . Его реализация следующая 1 :\nmember(X,[X|_]).\nmember(X,[_|T]):-member(X,T).\nПредикат интерпретируется следующим образом: «элемент\nсписка находится либо в голове, либо в хвосте списка». Пре-\nдикат демонстрирует, как применяются анонимные перемен-\nные. Тестировать работоспособность member/2 можно запро-\nсами member(b,[a,b,c]) и member(X,[1,2,3]) . Но вернемся\nк нашей основной задаче и посмотрим, как программа строит\nрешающие пути:\n1 Большинство\nреализаций языка Prolog не разрешают переопределять библиотечные пре-\nдикаты. Если собираетесь экспериментировать, то выберите для него какое-нибудь другое\nимя.\n48 3.2. Алгоритмы планирования действий\n?- dfsr(a, L, []).\nL = [a-b, b-c, c-f, f-e, e-d, d-h] ;\nL = [a-b, b-c, c-f, f-g, g-i, i-h] ;\nfalse.\nПрограмма находит всего два пути: а) решающие пути, б) пу-\nти без циклов. Распознавание циклов – процедура достаточно\nнакладная, она имеет сложность 𝑂(𝑛/2) «в среднем», где 𝑛 – дли-\nна пройденного пути. Но в сложных переборных задачах распо-\nзнавание циклов и экономит объем использованной памяти, и\nотсекает заведомо худшие варианты решения.\n3.2.2. Поиск в ширину\nСтратегия поиска в ширину (breadth-first search) обладает та-\nким же свойством, что и стратегия алгоритма IDA, т. е. первое\nнайденное решение будет оптимальным. Вот только достигает-\nся это без повторного перебора исследованной области графа 𝐷\n(рис. 3.1, a, с). Процесс поиска хранит все так называемые пути-\nкандидаты, пути, претендующие на то, чтобы стать решением.\nВсе пути-кандидаты начинаются в исходном узле и заканчивают-\nся текущей вершиной. Если текущая вершина – целевая, то такой\nпуть-кандидат становится решающим. Хранение списка путей-\nкандидатов не является лучшим решением по управлению опера-\nтивной памятью вычислительного процесса, но зато достаточно\nпросто реализуем:\nbfs([[X|T]|_],[X|T]):-p(X),!.\n% (1)\nbfs([[X|T]|Ways], S):-\nfindall([Y,X|T],\n% (2)\n49 3. Планирование действий\n(after(X,Y), \\+ member(Y,[X|T])), L),\nappend(Ways,L, NWays), % (3)\nbfs(NWays,S).\n% Истина где-то рядом...\nПервый аргумент bfs/2 – список путей-кандидатов, второй –\nрешающий путь. В обоих правилах [X|T] – путь-кандидат, нахо-\nдящийся на рассмотрении на данном шаге. Его голова X соответ-\nствует текущей вершине, начальная вершина находится в самом\nконце хвоста пути T . Путь-кандидат хранит решение в обратном\nпорядке: новые вершины добавляются в начало списка (2).\nВо втором правиле второй аргумент findall/3 является вы-\nражением (конъюнкцией) в скобках, порождающим переходы\nк дочерним вершинам, но только такие, которые не приводят к\nциклам. Библиотечный предикат append(L1,L2,L3) добавляет\nслева от L2 список L1 и порождает список L3 . Вот его не самая\nэффективная реализация [1]:\nappend([],L,L).\nappend([X|T1],L2,[X|T3]):-append(T1,L2,T3).\nВ первом правиле, в строке (1), использовано отсечение « ! »,\nв нашем случае запрещающее Prolog искать еще одно решение,\nесли первое уже найдено. Запрос на поиск первого оптимального\nрешения выглядит следующим образом:\n?- bfs([[a]],S).\nS = [h, d, e, f, c, b, a].\nВ результате действия отсечения интерпретатор выдал решение\nи без лишних вопросов прекратил дальнейшие поиски. В [1] при-\nведен вариант алгоритма, где подграф 𝐷 представляется в виде\nдерева, что значительно эффективнее списка путей-кандидатов.\n50 3.3. Использование дополнительной информации\nТеперь давайте займемся более сложными задачами, которые\nпорождают большое (в том числе бесконечное) пространство по-\nиска. Поиск решений в этих задачах занимает много ресурсов\nкомпьютера, если решать их простыми переборными алгоритма-\nми. Необходимо сделать так, чтобы область 𝐷 была как можно\nменьше, а поиск пытаться вести где-то рядом с вероятным реша-\nющим путем.\n3.3. Использование дополнительной информации\nОбобщим задачу планирования действий: добавим третий ар-\nгумент after/2 и получим after(X,Y,V) , где V – стоимость дуги,\nкоторая раньше была у всех дуг одинакова и равнялась 1 . Теперь\nстоимость решающего пути будет складываться из стоимостей со-\nставляющих его индивидуальных переходов. Дальнейшие наши\nрассуждения также будут подразумевать использование поиска в\nширину как базовой стратегии решения задач.\nПрактическая задача, обладающая в той или иной мере пере-\nчисленными свойствами, – это поиск маршрутов между города-\nми. Граф дорожной сети состоит из вершин (городов), дуг (дорог,\nсоединяющих два смежных города). Данные сети автомобиль-\nных дорог Российской Федерации в Интернете найти не удалось,\nзато в документе [12] содержится достаточно подробная, но не\nвполне корректная информация о расстояниях между станциями\nРоссийских железных дорог (РЖД). Все данные импортированы\nв базу данных SQLite rzd.sqlite и опубликованы на сервере\nпо адресу: https://github.com/eugeneai/ais/tree/cs/code .\n51 3. Планирование действий\nИмпорт данных осуществлен при помощи сценария (script), реа-\nлизованного на языке программирования Python [5, 9, 17]. Для\nисполнения дальнейшего программного кода необходимо ска-\nчать все файлы с указанного адреса к себе в рабочую папку.\nВ документе [12] среди всего множества станций выделяют-\nся станции, называемые транзитными пунктами (ТП). Судя по\nструктуре документа, расстояния от «обычных» станций указы-\nваются именно до транзитных пунктов. Примерами транзитных\nпунктов являются станции ’Иркутск-Пассажирский’ , ’Тайшет’ ,\n’Лена’ (г. Братск), ’Улан-Удэ’ . Решать задачу поиска кратчай-\nшего расстояния будем между транзитными пунктами, а задачу\nпоиска ближайшего транзитного пункта от обычных станций\nоставим в качестве упражнения. Дополнительную информацию\nбудем вычислять, исходя из физических параметров карты – гео-\nграфических координат транзитных пунктов. Координаты будем\nзапрашивать в Интернете на сервисе OpenStreetMap (OSM), а\nтакже сохранять их в базе данных для обеспечения быстрого до-\nступа. Рассмотрим, как SWI-Prolog взаимодействует с SQL – ба-\nзами данных. ↪ 56\n3.3.1. Доступ к базам данных\nВообще говоря, следует уточнить, о какой поддержке баз дан-\nных в Prolog идет речь. В интерпретаторе доступны:\n• встроенная база данных, реализуемая при помощи динами-\nческих предикатов, набора фактов, перечень которых меня-\nется при помощи предикатов assert/1 и retract/1 [1];\n52 3.3. Использование дополнительной информации\n• внешние базы данных, в том числе SQL. Далее будем гово-\nрить именно об этом.\nКак любой другой полноценный язык программирования, Pro-\nlog поддерживает организацию подпрограмм в отдельные мо-\nдули. Для того чтобы загрузить правила и факты из модуля до-\nступа к базам данных SQLite, надо выполнить инструкцию :-\nuse_module(library(prosqlite)). Такие инструкции являют-\nся запросами и исполняются в процессе загрузки программы.\nМодуль prosqlite не включен в дистрибутив SWI-Prolog по\nумолчанию, его необходимо загрузить из Интернета в виде од-\nноименного пакета. Чтобы получить список доступных пакетов,\nсодержащих в своем названии интересующий текст, надо выпол-\nнить поисковый запрос в интерпретаторе:\n?- pack_list(prosqlite).\n% Contacting server at http://www.swi-prolog.org/\n%\npack/query ... ok\np db_facts@0.1.0\n- Common db-tables-as-facts and\nSQL layer for ODBC and SQLite.\np prosqlite@1.0\n- An SWI-Prolog interface to\nSQLite\nУстановка пакета, как и выполнение предыдущего запроса,\nтребует наличия соединения с Интернетом 1 . В процессе уста-\nновки интерпретатор может спросить, стоит ли продолжать уста-\nновку, а также куда следует устанавливать библиотеку (Create\ndirectory for packages). Отвечать следует нажатием\n1 На\ny\n.\nсамом деле можно загрузить архив пакета и выполнить установку и без подключения к\nИнтернету. Процедура установки описана на сайте SWI-Prolog [16].\n53 3. Планирование действий\n?- pack_install(prosqlite).\n% Contacting server at ... ok\nInstall prosqlite@1.0 from http://stoics... Y/n?\nCreate directory for packages\n(1) * /home/eugeneai/lib/swipl/pack\n(2)\nCancel\nYour choice? 1\n% Contacting server at ... ok\n% ”prosqlite-1.0.tgz” was downloaded 7 times\nPackage: prosqlite\nTitle: An SWI-Prolog ... SQLite\nInstalled version: 1.0\nAuthor: Sander Canisius, ...\nMaintainer: Nicos Angelopoulos\nPackager: Nicos Angelopoulos\nHome page: http://stoics.org.uk/...\nDownload URL: http://stoics.org.uk/...\nInstall ”prosqlite-1.0.tgz” (740,988 bytes) Y/n?\n% Found foreign libraries for target platform.\n% Use ?- pack_rebuild(prosqlite). to rebuild ...\nВ заключение установки проверим, загружается ли наш мо-\nдуль (библиотека):\n?- [library(prosqlite)].\n% library(prosqlite) compiled into prosqlite\n% 0.01 sec, 116 clauses\n54 3.3. Использование дополнительной информации\nПредставление таблиц в виде предикатов. SWI-Prolog поз-\nволяет непосредственно выполнять SQL-запросы к базе данных,\nв результате запроса последний аргумент связывается со струк-\nтурой row(…) для каждой возвращаемой записи. Аргументами\nданной структуры являются значения атрибутов записи:\n?- sqlite_connect(rzd, db, [as_predicates(true)]).\n?- sqlite_query(db,\n’SELECT * FROM station LIMIT 3’, Row).\nRow = row(’Вентспилс (эксп.)’,’Лат’,98306,0) ;\nRow = row(’Шаблиевская’,’С-Кав’,518827,0) ;\nRow = row(’Салар’,’Узбк’,720903,0) ;\nfalse.\nПервый запрос создает соединение с базой данных rzd.sqlite ,\nпри этом соединение ассоциируется с атомом db , который далее\nиспользуется как глобальный идентификатор этого соединения.\nТретий аргумент настраивает дополнительные возможности биб-\nлиотеки – представление таблиц базы данных в виде предикатов\nязыка Prolog. Второй запрос к Prolog является SELECT -запросом\nк таблице данных о существующих станциях station . Prolog\nвыдал три ответа, затем волнение запроса закончилось неуда-\nчей. Теперь воспользуемся дополнительными возможностями\nбиблиотеки и запросим перечень станций по-прологовски, а со-\nответствующий запрос на выборку данных он синтезирует сам:\n?- station(Name,Region,Code,TP).\nName = ’Вентспилс (эксп.)’,\nRegion = ’Лат’, % Регион\nCode = 98306, % Ж/Д-код станции\nTP = 0 ; % Транзитный пункт?\n55 3. Планирование действий\nName = ’Шаблиевская’,\n% Название станции\nRegion = ’С-Кав’,\nCode = 518827,\nTP = 0\nЕсли требуется узнать только транзитные пункты, то надо просто\nуказать значения соответствующих параметров:\n?- station(Name,’В-Сиб’,Code,1).\nName = ’Лена’,\nCode = 927105 ;\nName = ’Иркутск-Пассажирский’,\nCode = 930108 ;\nName = ’Улан-Удэ’,\n. . . . . . . . .\nТеперь запросы к базам данных можно комбинировать с дру-\nгими предикатами программы. Соединение с базой данных раз-\nрывается предикатом sqlite_disconnect(db) . В таблице 3.1\nприведены данные о структуре основных таблиц базы данных\nrzd.sqlite . Структуры остальных таблиц можно посмотреть\nпри помощи команды « .schema », подключившись к базе данных\nsqlite3 rzd.sqlite .\nВозвращаемся к задаче поиска оптимального пути.\nИтак, у\nнас есть база данных с необходимыми таблицами и данными.\nТеперь наша задача – построить алгоритм, осуществляющий\nпоиск оптимального пути в ГПС сети железных дорог РЖД, эф-\nфективно использующий процессор. Сначала обобщим поиск в\nширину – учтем тот факт, что дуги теперь нагружены (дороги,\nсоединяющие города, разной длины):\n56 3.3. Использование дополнительной информации\nТаблица 3.1\nОсновные таблицы базы данных структуры РДЖ\nТаблица station\nТаблица geocache\nname text, Название станции station int, Код ТП\nregion int, Филиал РДЖ lon int, Долгота\ncode int, Код станции lat int Широта\ntransit int Это ТП? lat place_id OSM-код объекта\nТаблица route\nТаблица dist\na int, Первый ТП a int, Код станции\nb int, Второй ТП b int, Код ТП\ndist int Расстояние dist int Расстояние до ТП\nucs([_-[Target|T] |_],Target,[Target|T]):-!.\nucs([G-[X|T]|Ways], Target, S):-\nTarget\\=X,\nfindall(G1-[Y,X|T], after([X|T],G, Y,G1), L),\nappend(L, Ways, NWays),\nkeysort(NWays,SNWays),\nucs(SNWays,Target,S).\nafter([S|R],SG, T,TG):-\ntransdist(S,T,D),\n% Расстояние D между\n\\+ member(T,[S|R]),\nTG is SG + D.\n% ТП S и T\n% Приращение стоимости пути\nВ новой программе проверка вхождения дочерней вершины в\nпройденный путь и вычисления стоимости нового пути вынесе-\nны в предикат after/4 , и поэтому в первый аргумент передается\nне вершина, а пройденный путь. Предикат after/4 по сравне-\nнию с after/2 дополнен двумя аргументами: SG – стоимость\nпройденного пути [S|R] , TG – стоимость пути [T,S|R] . Список\n57 3. Планирование действий\nпутей-кандидатов теперь оформлен в виде структуры G-W , где\nW – путь-кандидат, G – его стоимость. В ucs/3 добавлен новый\nаргумент – название целевой станции: в задаче целевая вершина\nвсего одна, да и удобнее задавать конечную станцию в запро-\nсе, а не программе. Далее, предикат keysort(NWays, SNWays)\nсортирует список NWays двоек G-W по возрастанию значения G .\nСортировка выполняется при помощи алгоритма быстрой сорти-\nровки над всем списком NWays . Алгоритм реализован на языке\nC как двоичный модуль и выполняется достаточно эффективно,\nпоэтому левые два аргумента append/3 переставлены местами:\nдлина (в элементах) списка L значительно меньше, чем длина\nсписка Ways . Таким образом, первым элементом в отсортирован-\nном списке двоек SNWays оказывается двойка с минимальной\nстоимостью пути-кандидата.\nЗапрос на поиск пути между железнодорожными станциями –\nстолицами двух российских регионов выглядит следующим об-\nразом 1 :\n?- ucs([0-[’Улан-Удэ’]],’Новосибирск-Главный’,S).\nS = [Новосибирск-Главный,Сокур,Юрга I,Тайга, Анжерская,\nАчинск I,Уяр, Тайшет, Иркутск-Пассажирский,Улан-Удэ]\nВ программе bfs/2 новые пути-кандидаты добавлялись в ко-\nнец существующего списка путей-кандидатов, и список при этом\nоставался упорядоченным. В ucs/3 так сделать не получится,\nтак как вставлять новые пути уже надо внутрь списка. Поэтому\nприходится использовать быструю сортировку на каждом шаге,\n1 В\nсписок станций не входит «Красноярск-Главный», так как в базе данных он не является\nтранзитным пунктом.\n58 3.3. Использование дополнительной информации\nсортировка вставкой не даст дополнительных преимуществ для\nрекурсивных списков в Prolog. Ускорить процесс вставки можно\nза счет использования сбалансированных деревьев для представ-\nления списка путей-кандидатов.\nПредставленный алгоритм называется «Поиск по критерию\nстоимости» (метод равных цен, Uniform-Cost Search, UCS). Ес-\nли стоимости всех дуг в ГПС положительны, то UCS является\nполным и оптимальным, так же как и алгоритм поиска в ширину.\nВместо перехода в ближайший к исходной вершине узел UCS\nпереходит (раскрывает) в вершину с минимальной стоимостью\nпути до исходной вершины. Если все стоимости дуг одинаковы,\nUCS превращается в поиск в ширину.\n3.3.2. Алгоритм A ∗\nТеперь посмотрим, как можно ускорить поиск, используя до-\nполнительную информацию. На рисунке 3.3, а показана железно-\nдорожная сеть (ГПС) Южного Урала, Западной Сибири и Казах-\nстана. На примере этой сети продемонстрирован процесс UCS\nраскрытия вершин ГПС во время поиска решения. Задача состо-\nит в том, чтобы найти путь со станции Тобол до станции Омск.\nПунктирными окружностями обозначена область 𝐷 на разных\nэтапах поиска. Как видно, UCS не делает никаких предположе-\nний о местонахождении Омска и вынужден «ходить» вокруг\nначальной вершины, на каждом шаге постепенно увеличивая\nрадиус окружности. На практике всегда возникает вопрос: «В\nкакую сторону следует двигаться, чтобы исключить неподходя-\nщие вершины ГПС и быстрее добраться до целевой вершины?».\n59 3. Планирование действий\nВ нашем примере в качестве такого направления выступает на-\nправление на целевую вершину (рис. 3.3, b).\nТюмень\nТюмень\nОмск\nОмск\nПетропавловск\nПетропавловск\nКурган\nКурган\nСвердловск\nСвердловск\nКокчетав\nКокчетав\nЧелябинск\nЧелябинск\nНовоишимская\nНовоишимская\nТроицк\nТроицк\nКустанай\nКовыльная\nЕсиль\nКарталы\nКустанай\nКовыльная\nАтбасар\nАстана\nКарталы\nТобол\nАтбасар\nЕсиль\nАстана\nТобол\nШильда\nШильда\na)\nb)\nРис. 3.3. Сужение области поиска\nЗададим стоимость кратчайшего решающего пути, проходя-\nщего через некоторую вершину ГПС 𝑥 , функцией 𝑓∶ 𝑉 → 𝑅 сле-\nдующего вида:\n𝑓(𝑥) = 𝑔(𝑥) + 𝑟(𝑥),\n(3.1)\nгде 𝑔(𝑥) – стоимость кратчайшего пути из начальной вершины\nдо вершины 𝑥 , а 𝑟(𝑥) – стоимость пути из 𝑥 до целевой вершины.\nЕсли 𝑥 является целевой вершиной, то 𝑟(𝑥) = 0 и 𝑔(𝑥) = 𝑓(𝑥) ,\nт. е. значения функций равны стоимости решающего пути. Если\n𝑥 не является целевой, то значение 𝑟(𝑥) не известно. Если зна-\nчение 𝑓(𝑥) можно было бы вычислить для любой вершины 𝑥 ,\nто тогда можно было бы разработать алгоритм поиска, который\nточно «знает», куда следует идти на каждом шаге построения\nрешения. Несмотря на то что такое в общем случае невозмож-\n60 3.3. Использование дополнительной информации\nно, кое-что все-таки сделать можно: будем оценивать величину\n𝑟(𝑥) снизу некоторой функцией ℎ(𝑥) . Для всех 𝑥 должно выпол-\nняться неравенство 𝑟(𝑥) ⩽ ℎ(𝑥) . Значения функции 𝑓(𝑥) будем\nоценивать таким образом:\n𝑓(𝑥) ⩾ 𝑔(𝑥) + ℎ(𝑥).\n(3.2)\nВ нашей задаче значения ℎ(𝑥) соответствуют расстоянию меж-\nду городами, т. е. по самой короткой линии на поверхности сферы.\nДля вычисления этого расстояния нам потребуется база данных\ngeocache (табл. 3.1) и реализация подсистемы запроса географи-\nческих координат на сервере OpenStreetMap, которым в этот раз\nзаймемся чуть позже.\nПрограмма поиска, основывающегося на оценке ℎ(𝑥) , состо-\nит из трех основных предикатов. Первый предикат – after/6 ,\nкоторый получает еще два дополнительных параметра: GPS – ко-\nординаты целевой вершины (входной параметр), F – оценка 𝑓(𝚃)\nдля дочерней вершины T (выходной параметр). Вторым преди-\nкатом выступает bf1/3 , являющийся реализацией собственно\nалгоритма поиска. Третий предикат – это процедура bf/3 , подго-\nтавливающая данные для основного предиката bf1/3 :\nbf1([_-s(G,[Target|T]) |_],\n% (1)\nTarget-_,s(G,[Target|T])):-!.\nbf1([_-s(G,[X|T])|Ways], Target-GPS, S):-\nTarget\\=X,\nfindall(F1-s(G1,[Y,X|T]),\nafter([X|T],G,GPS, Y,G1,F1), L),\nappend(L, Ways, NWays), keysort(NWays,SNWays),\nbf1(SNWays,Target-GPS,S).\n61 3. Планирование действий\nafter([S|R],SG, GPS, T,TG, F):-\ntransdist(S,T,D),\n\\+ member(T,[S|R]),\nTG is SG + D,\ngeodist(T, GPS, GDist),\n% (2)\nF is TG + GDist.\nbf(Start, Target, Sol):-\ngeocode(Target, Lon, Lat, _),\nbf1([0-s(0,[Start])],\nTarget-ll(Lon,Lat), Sol). % (3)\nИспользуемые в программе структуры также немного услож-\nнены по сравнению с UCS. Элемент списка путей-кандидатов\n(1) теперь представляет собой структуру вида F-s(G,[X|T]) , где\nX – текущая вершина, G – стоимость пройденного пути 𝑔(𝚇) до\nтекущей вершины, F – оценка 𝑓(𝚇) . Параметр GPS предиката\nafter/6 – структура ll(Lon,Lat) , Lon – долгота целевой верши-\nны, Lat – ее широта. Оба значения заданы в градусах. Структура\nсоздается в строке (3) и передается в составе двойки Target-GPS .\nОценка ℎ(𝚃) вычисляется в geodist/2 в строке (2). Приведем\nпример поиска кратчайшего пути между двумя станциями:\n?- bf(’Свердловск-Сортировочный’, ’Новосибирск-Главный’, S),\nwrite(S).\nOSM: Пермь II\nlon: 56.1744706, lat:58.0050018\n% (1)\nS = s(1535,[Новосибирск-Главный,Обь,Татарская,Карбышево I,\nВойновка,Тюмень,Богданович,Шарташ,\nСвердловск-Сортировочный])\n62 3.3. Использование дополнительной информации\nВ результате запроса получается структура, которая содержит\nрешающий путь и его стоимость (длина в км). В процессе постро-\nения решения программа запрашивает данные местоположения\nстанций в Интернете. Результаты запросов выдаются на экран в\nвиде отладочной информации (1).\nПостроенная нами реализация алгоритма 𝙰 ∗ основывается на\nнепереоценивающей функции ℎ , т. е. выдает первым оптималь-\nное решение. Необходимо сделать пару замечаний.\n1. Расстояние между городами вычисляется в пространстве на\nсфере, что не отражает структуры железнодорожной сети.\nНапример, расстояние между Москвой и Иркутском состав-\nляет чуть меньше 4200 км, траектория полета самолета про-\nходит вблизи города Сургута, находящегося значительно\nсевернее Трассиба.\n2. Запуская программу, можно наблюдать, что гарантированно\nполучить правильные координаты станции у нас не всегда\nполучится: сервис OSM не специализируется на предостав-\nлении координат станций и может выдавать координаты\nобъектов со схожим названием. Так, например, на момент\nпубликации данного пособия не удалось правильно опреде-\nлить координаты станции Лена, которая находится в городе\nБратске Иркутской области.\nПосле небольшого экскурса в обработку файлов XML (eXtensible\nMarkup Language) и доступа в Интернет рассмотрим решение\nболее общих задач на основе переборных алгоритмов. ↪ 70\n63 3. Планирование действий\n3.3.3. Доступ в Интернет и обработка XML\nЯзык программирования Prolog представляет собой удобное\nсредство обработки рекурсивных структур. Использованные на-\nми в разделе 3.2.2 списки относятся к таким рекурсивным струк-\nтурам. Другой известной рекурсивной структурой является де-\nрево, которое лежит в основе структуры формата данных XML.\nФормат XML позволяет представлять информацию таким обра-\nзом, чтобы она, с одной стороны, достаточно эффективно обра-\nбатывалась алгоритмически (на компьютере), а с другой, была\nпонятна человеку. Вот, например, ответ с сервера геокодирова-\nния Nominatim [14]:\n<?xml version=”1.0” encoding=”UTF-8” ?>\n<searchresults timestamp=’Thu, 15 Jan 15 07:54:30 +0000’\nattribution=’Data © OpenStreetMap contributors, ODbL\n1.0. http://www.openstreetmap.org/copyright’\nquerystring=’Иркутск’\noviewbox=’-112.15,61.44,112.15,-61.44’\npolygon=’false’\nexclude_place_ids=’158888259’\n>\n<place\nplace_id=’158888259’ osm_type=’relation’ osm_id=’1430614’\nplace_rank=’16’\nboundingbox=”52.2094352,52.4217324,104.0579985,104.462928”\nlat=’52.2895979’ lon=’104.2805843’\ndisplay_name=’Иркутск, городской округ Иркутск, Иркутская\nобласть, Сибирский федеральный округ, Российская\nФедерация’\nclass=’place’ type=’city’ importance=’0.70744217496694’/>\n</searchresults>\n64 3.3. Использование дополнительной информации\nОсновные элементы XML – это теги, атрибуты и текст, за-\nполняющий пространство между тегами. В данном примере тега-\nми выступают <searchresults> и <place> . Тег <place> распо-\nложен «внутри» тега <searchresults> . Тег <searchresults> –\nкорневой, который по стандарту XML должен быть только один,\nостальные могут повторяться. В нашем примере сервер геоко-\nдирования может выдать несколько объектов, соответствующих\nзапросу. В XML-ответе сервера это отразится наличием повторе-\nний тега <place> для каждого объекта.\nАтрибуты ассоциированы с тегами и несут формализованную\nдополнительную информацию. В примере тегами lat и lon за-\nданы географические координаты объекта (города Иркутска),\nполное наименование ( display_name ), тип объекта type и т. д.\nКаждый атрибут приравнивается к некоторому значению. Таким\nобразом, тег place со своими атрибутами описывает объекты, а\n<searchresults> – результат обработки запроса, состоящий из\nодного или нескольких объектов.\nПроцедуры (предикаты) обработки XML, запросы к сайтам\nИнтернета, а также обработка списка ключевых слов (атрибутов)\nреализованы в соответствующих библиотеках среды Prolog. В\nнашей программе необходимо импортировать эти библиотеки:\n:- use_module(library(http/http_open)).\n:- use_module(library(sgml)).\n% Обработка XML\n:- use_module(library(option)).\nПредикат geocodequery/4 запрашивает на сервере объекты\nпо названию Name и возвращает широту, долготу и идентифи-\nкатор объекта. Библиотечная процедура http_open в качестве\n65 3. Планирование действий\nпервого аргумента принимает список ключевых слов в формате\n<название структуры>(<значение>) . Элементы списка позволя-\nют формировать строку URL-запроса к серверу из отдельных\nкомпонент. Важным элементом этого списка является search/1\nсо списком параметров запроса к скрипту search.php . Параметр\nformat указывает серверу на тот факт, что ответ (перечень объек-\nтов) надо возвращать в виде XML. Остальные значения понятны\nна интуитивном уровне.\nПеременная In получает идентификатор входного потока дан-\nных, представляющих собой ответ сервера. Этот поток передает-\nся в процедуру интерпретации XML в виде текста. Текст транс-\nлируется в древовидное представление и помещается в перемен-\nную S . Переменная S затем унифицируется со структурой, чтобы\nразобрать корневой тег на отдельные элементы. Унификация по-\nмещает в L список тегов <place> . Этот список анализируется в\nпредикате geoplace/4 , где изымаются требуемые данные о ме-\nстоположении найденных объектов.\ngeocodequery(Name, Lon, Lat, ID):-\nhttp_open([\nhost(’nominatim.openstreetmap.org’),\npath(’/search.php’),\nsearch([ q=Name,\nlang=ru,\nformat=xml ])\n], In, [] ),\nload_xml(In, S, []),\nS=[element(searchresults,_,[_|L])],\nclose(In), geoplace(L, Lon,Lat,ID),\n66 3.3. Использование дополнительной информации\nwritef(”OSM: %w lon: %w, lat:%w”,\n[Name, Lon, Lat]),nl.\ngeoplace(element(place,Attrs,_), Lon, Lat, Id):-\noption(lon(Lon1),Attrs), atom_number(Lon1,Lon),\noption(lat(Lat1),Attrs), atom_number(Lat1,Lat),\noption(place_id(Id),Attrs).\ngeoplace([X|_], Lon, Lat, Id):-\ngeoplace(X, Lon, Lat, Id).\ngeoplace([_|T], Lon, Lat, Id):-\ngeoplace(T, Lon, Lat, Id).\nПредикат geoplace в качестве первого параметра принимает\nструктуру element(place, <список атрибутов>, []) , соответ-\nствующую тегу place , или список таких структур. Предикат воз-\nвращает геоданные об объектах, представленных в списке тегов\nplace . Предикат option(lon(Val),L) ищет в списке L элемент\nвида lon=Val или lon(Val) и унифицирует соответствующим\nзначением переменную Val . Процедура atom_number(X,Y) пере-\nводит атомы X (строки) в целые числа Y (и наоборот), если такое\nвозможно.\nСледующий текст представляет собой программу обеспечения\nдоступа предикату after/6 к геоданным по названию станции\nStation :\ngeocode(Station, Lon, Lat, Id):-\n\\+ number(Station),\nstation(Station, _, Code, _),\ngeocode(Code, Lon, Lat, Id).\n67 3. Планирование действий\ngeocode(Station, Lon, Lat, Id):-\nnumber(Station),\ngeocache(Station, Lon, Lat, Id),!.\ngeocode(Station, Lon, Lat, Id):-\nnumber(Station),\nstation(Name, _, Station, _),\ngeocodequery(Name, Lon, Lat, Id),\nsqlite_query_f(db,\n’INSERT INTO geocache (station, lon, lat,\nplace_id) values\n(%w,%w,%w,%w)’-[Station,Lon,Lat,Id], _),!.\nСначала geocode/4 пытается найти данные в локальной ба-\nзе данных координат geocache/4 . Если попытка терпит неуда-\nчу, то осуществляется запрос к интернет-сервису Nominatim и\nзапись результата в базу данных geocache для дальнейшего ис-\nпользования. В тексте SQL-запроса INSERT %w обозначает место\nвставки строкового представления очередного значения из спис-\nка [Station,Lon,…] . Предикат sqlite_query_f/3 реализован в\nпрограмме следующим образом:\nsqlite_query_f(Conn, S-Args, ROW):-\nswritef(Query, S, Args),\nsqlite_query(Conn, Query, ROW).\nВсеми преобразованиями %w в форматной строке S в конкрет-\nные значения из списка Args занимается библиотечный предикат\nswritef/3 . Результат преобразования записывается в перемен-\nную Query .\n68 3.3. Использование дополнительной информации\nИз приведенных примеров программного кода хорошо видно,\nчто синтез двух реляционных языков программирования в рам-\nках одного приложения производится достаточно просто, при\nэтом не надо изобретать дополнительные конструкции, напри-\nмер циклы по строкам результата запроса. Поэтому, разрабатывая\nв следующий раз информационную систему со встроенными\nподсистемами математического моделирования, следует заду-\nматься над вопросом о том, где в ней будут использоваться импе-\nративные языки программирования, а какие подсистемы следует\nреализовать на реляционном языке программирования.\n69 4. Поиск решения на основе перебора\nИногда приходится сталкиваться с задачами, эффективный\nалгоритм решения которых очевидным образом реализовать не\nудается, либо недостаточно времени на анализ свойств задачи и\nпоиск подходящего алгоритма. К ним относятся, например, за-\nдачи с удовлетворением ограничений 1 . Такие задачи являются\nматематическими проблемами, определенными на конечном на-\nборе объектов, чьи значения должны удовлетворять ряду ограни-\nчений, выраженных в виде неравенств и логических выражений.\nИсследования в области решения задач CSP ведутся достаточ-\nно давно, и по сей день актуальность этих исследований только\nповышается.\nК задачам CSP сводятся многие задачи искусственного ин-\nтеллекта, в частности планирование действий. Задачи удовле-\nтворения ограничений довольно часто демонстрируют большую\nкомбинаторную сложность, и практически для каждой индиви-\nдуальной задачи строятся собственные варианты эвристических\nалгоритмов 2 их решения. Примеры известных задач: «Восемь\nферзей», «Раскраска карты», «Судоку», «Поиск выполняющего\nнабора», «Составление расписания вуза».\nФормально задачи CSP определяются следующим образом.\nЗаданы вектор переменных 𝑉 ⃗ = ⟨𝑣 1 , 𝑣 2 , … , 𝑣 𝑛 ⟩ , где 𝑛 – количество\nпеременных (натуральное); множество множеств 𝐷 = {𝑑 1 , 𝑑 2 , … ,\n1 Англ.\nConstraint satisfaction problems, CSP.\nв которых на этапах выбора очередного направления поиска решения из\n2 Алгоритмов,\nнескольких альтернатив используется дополнительная (по отношению к исходной) ин-\nформация для задания этим альтернативам некоторого предпочтения.\n70 4.1. Алгоритм British Museum\n𝑑 𝑛 } , где 𝑑 𝑖 – непустое множество значений (домен), которые мо-\nжет принимать переменная 𝑣 𝑖 , 𝑖 = 1, 2, … , 𝑛 . Задается также ло-\n⃗ = 𝑃(𝑣 1 , 𝑣 2 , … , 𝑣 𝑛 ) , которое истинно, если\nгическое условие 𝑃( 𝑉)\nзначения, присвоенные переменным 𝑣 𝑖 , соответствуют условиям\nправильной комбинации. Например, для задачи «Восемь ферзей»\n⃗ истинно, если все ферзи, расставленные на доске, не бьют\n𝑃( 𝑉)\nдруг друга. Иногда говорят о системе ограничений и о таких\nзначениях переменных, при которых все ограничения выпол-\nняются (истинны). Систему ограничений можно записать как\nконъюнкцию индивидуальных ограничений, т. е. свести опять\n⃗ .\nже к единому логическому условию 𝑃( 𝑉)\n4.1. Алгоритм British Museum\nОдним из простых алгоритмов, решающих задачи CSP, являет-\nся алгоритм British Museum 1 . Алгоритм реализует самый общий\nподход в задачах поиска решения на основе последовательной\nпроверки всех возможностей (одну за одной), начиная с самых\nпростых решений.\nАлгоритм реализует концептуальный, а не практический под-\nход, оперируя огромным количеством возможных альтернатив.\nВ частности, в теории он представляет способ найти самую ко-\nроткую программу, которая решает конкретную задачу. Напри-\nмер, можно сгенерировать все возможные программы длиной\nв один символ, проверить каждую программу – решает ли она\n1 В советской литературе вариант этого подхода известен как метод «Отобразить и проверить»\n(источник информации, к сожалению, потерян). В настоящее время широко используется\nтермин «Метод грубой силы» (Brute Force Approach) для обозначения данного подхода.\n71 4. Поиск решения на основе перебора\nэту задачу 1 . Если среди односимвольных программ не найдено\nпрограммы, решающей задачу, перейти к просмотру программ\nдлиной в два символа, затем в три и т. д. В теории такой подход\nпозволяет найти самую короткую программу, однако на практике\nперебор занимает недопустимо большое время вычислений (для\nмногих задач больше, чем возраст Вселенной).\nНазвание данный алгоритм получил после высказывания Ал-\nлена Ньювэлла, Дж. С. Шоу и Герберта А. Симона в 1958 году:\n«Вполне уместно предположить, что если посадить обезьян за\nпечатные машинки, можно через некоторое время воспроизвести\nвсе книги в известном Британском музее в Лондоне».\nНесмотря на всю идеалистичность подхода, для задач неболь-\nшой размерности алгоритм вполне пригоден. Для начала, ко-\nнечно, нет необходимости порождать программы, достаточно\nпорождать варианты значений переменных 𝑣 𝑖 , затем проверять\n⃗ . Рассмотрим пример задачи.\nвыполнимость 𝑃( 𝑉)\nПример 4.1. Разработать программу поиска номеров счастли-\nвых билетов, содержащих шесть цифр. Подсчитать их количе-\nство.\nnum(X) :- member(X, [0,1,2,3,4,5,6,7,8,9]).\ngen([]).\ngen([X|T]) :- num(X), gen(T).\np([A,B,C, D,E,F]) :-\nA + B + C =:= D + E + F.\n1 Существует\nфундаментальная проблема остановки, которая делает такую проверку, в общем\nслучае, невозможной.\n72 4.1. Алгоритм British Museum\nlucky([A,B,C, D,E,F]) :-\ngen([A,B,C, D,E,F]),\np([A,B,C, D,E,F]).\nПрограмма при помощи предиката gen/1 порождает иденти-\nфикаторы билетов. Предикат p/1 проверяет, является ли билет\nсчастливым. Процедура порождения списка счастливых биле-\nтов оформлена в виде предиката lucky/1 и в комментариях не\nнуждается. Для запуска программы выполним команду:\n?- lucky(L).\nL = [0,0,0,0,0,0] ? ;\nL = [0,0,1,0,0,1] ? ;\nL = [0,0,1,0,1,0] ? ;\nL = [0,0,1,1,0,0] ?\nyes.\nДля подсчета количества счастливых билетов создадим еще одно\nвспомогательное правило:\ncount(N) :- findall(Ticket, lucky(Ticket),\nTickets), length(Tickets, N).\nДанное правило позволяет подсчитывать количество счастливых\nбилетов, но не выводить их полный список на экран.\nВыполним запрос (GNU-Prolog) [13]:\n?- count(N).\nN = 55252\n(630 ms) yes.\n73 4. Поиск решения на основе перебора\nПриведенные программы являются также примерами исполь-\nзования стандартных member/2 и length/2 предикатов обработ-\nки списков.\nСужение области поиска. Программа перебирает 10 6 вари-\nантов, из которых только около 5, 5 ⋅ 10 4 относятся к решению\nзадачи. То есть примерно один из двадцати билетов – счастли-\nвый. Возникает вопрос: можно ли усовершенствовать программу,\nчтобы уменьшить количество неправильных вариантов и сэко-\nномить время решения задачи на проверке этих неправильных\nвариантов?\nПервым делом давайте попробуем вычислить значение пере-\nменной F is A+B+C-D-E . Добавим к программе следующий код:\nlucky2([A,B,C, D,E,F]) :-\ngen([A,B,C, D,E]),\nF is A+B+C-D-E,\nnum(F),\np([A,B,C, D,E,F]).\ncount2(N) :- findall(Ticket, lucky2(Ticket),\nTickets), length(Tickets, N).\n?- count2(N).\nN = 55252\n(133 ms) yes.\nПолучено такое же количество решений, но за время, в пять\nраз меньшее. Вычисленное значение F может быть отрицатель-\nным и больше 9, что противоречит условиям задачи, поэтому\n74 4.1. Алгоритм British Museum\nв новую процедуру порождения билетов необходимо добавить\nдополнительную проверку num(F) , которая выполняется, если\nF находится в требуемом диапазоне. Теперь порождается в 10\nраз меньше билетов, даже с учетом тех, где F находится вне диа-\nпазона. То есть каждый второй сгенерированный билет – счаст-\nливый. Если убрать уже ненужную повторную проверку p/1 , то\nскорость исполнения программы увеличится еще на 30 % до 106\nмикросекунд, т. е. уже более чем в 6 раз быстрее первоначальной:\n?- count2(N).\nN = 55252\n(103 ms) yes.\nДополнительное ускорение. Теперь попробуем найти два по-\nследних числа. Выражение A+B+C-D изменяется в пределах −9,\n−8, … , 0, 1, … , 26, 27 : от 0+0+0-9 до 9+9+9-0 . Варианты, когда ре-\nзультат выражения – отрицательный, заведомо неподходящие,\nтак же как если этот результат больше 18 , 9+9+9-9 . Можно еще\nусовершенствовать алгоритм, но оставим это в качестве упраж-\nнения. Теперь надо разработать подпрограммы, которые для диа-\nпазона 0, 1, … , 18 будут решать просто отдельную переборную\nзадачу: задано число S ∈ 0, 1, … , 18 , найти два слагаемых E и F ,\nдающих в сумме S . Дополним программу следующим кодом:\nlucky3([A,B,C, D,E,F]) :-\ngen([A,B,C, D]),\nS is A+B+C-D,\nS >= 0, S=<18,\ngen2(S, E,F).\n75 4. Поиск решения на основе перебора\ncount3(N) :- findall(Ticket, lucky3(Ticket),\nTickets), length(Tickets, N).\ngen2(0,0,0):-!.\n% Выделим отдельно наглядные\ngen2(18,9,9):-!. % тривиальные варианты.\ngen2(N,A,B):-N<10, !, igen(N,A), B is N - A.\ngen2(N,A,B):-D is N - 9, Z is 9 - D,\nigen(Z, A1), A is A1 + D, B is N - A.\n% igen(N, A) для A порождает последовательности\n% 0,1,2,...,N\nigen(N, A) :- N>=1, M is N - 1, igen(M, A).\nigen(N, N).\nЗапускаем запрос:\n?- count3(N).\nN = 55252\n(47 ms) yes.\nТеперь программа работает в 13 с лишним раз быстрее перво-\nначальной и в два раза быстрее предыдущей, т. е. примерно один\nиз трех билетов не является счастливым. Конечно, программу\nможно совершенствовать дальше: перейти к порождению первых\nтрех цифр и, отталкиваясь от их суммы, по аналогии с послед-\nним примером порождать соответствующие последовательности.\nОднако необходимо заметить, что программа 1 постепенно стано-\nвится сложной, а текст значительно хуже воспринимаемым.\n1 Автор\nпособия не ставил целью найти самую эффективную и короткую программу для\nрешения этой задачи. Задача – продемонстрировать ход рассуждений.\n76 5. Компьютерная алгебра\nСтаршее поколение преподавателей недовольно уровнем зна-\nний студентов вузов в области математического анализа, особен-\nно в части знаний оператора дифференцирования. Студентам не\nразрешают пользоваться популярными системами компьютер-\nной алгебры. По-видимому, сказывается недостаточная практика\nв этом направлении. Действительно, прежде чем автоматизи-\nровать некоторую творческую деятельность, необходимо де-\nтально в ней разобраться, и, самое главное, разбираться в случае\nнеобходимости.\nДавайте продвинемся в решении двух проблем сразу – повто-\nрим дифференцирование и разработаем ядро своей компьютер-\nной алгебры. В качестве побочного продукта получим навыки\nобработки символьной информации – решения важного класса\nзадач ИИ.\n5.1. Символьное дифференцирование\nЧастную производную функции 𝑓(𝑥, 𝑦, …) по переменной 𝑥\nобозначают как\n𝑓 𝑥 ′ , 𝑓 𝑥 ,\n𝜕\n𝜕𝑓\n𝑑 𝑓\n𝑓,\n, или 𝑥 .\n𝜕𝑥 𝜕𝑥\n𝑑𝑥\nВ языке Prolog обозначим частную производную предикатом\nd(F,X,DF) , где F – функция, производная DF которой «берется»\nпо переменной X . Программу нахождения производных из функ-\nций (выражений) начнем писать с самых простых вариантов:\nпроизводной переменной, константы и атома.\n77 5. Компьютерная алгебра\nd(Y,X,1):-var(X),var(Y),\nY==X,!.\nd(Y,X,0):-\nvar(Y),var(X),!.\nd(C,_,0):-atomic(C),!.\nПредикат « ==/2 » позволяет определять, не с одной ли той же\nпеременной унифицированы X и Y . Предикат var/1 проверяет,\nявляется ли аргумент все еще переменной или нет. Выполним\nтестовые запросы:\n?- d(X,X,D). | ?- X=Y,d(Y,X,D).\nD = 1. | X = Y,\n| D = 1.\n?- d(Y,X,D). | Y = A, | ?- d(1,X,D).\nX = B, | D = 0.\nD = 0. |\n|\n?- d(a,X,D). |\nD = 0. |\nСледующий этап – реализация правила преобразования ариф-\nметических операций:\nd(U+V,X,DU+DV):-!, |\nd(U*V,X,DU*V+DV*U):-!,\nd(U,X,DU), | d(U,X,DU),\nd(V,X,DV). | d(V,X,DV).\n|\nd(U-V,X,DU-DV):-!, | d(U,X,DU), | d(U,X,DU),\nd(V,X,DV). | d(V,X,DV).\n78\nd(U/V,X,(DU*V-DV*U)/(V^2)):-!, 5.1. Символьное дифференцирование\nТеперь рассмотрим суперпозицию функций, формула являет-\nся рекурсивной (цепной):\n𝜕\n𝜕𝑓 𝜕𝑔\n𝑓(𝑔(𝑥)) =\n.\n𝜕𝑥\n𝜕𝑔 𝜕𝑥\nСоответствующее правило Prolog будет следующим:\nd(E,X, DExpF*DExp):-\nE=..[Atom, Exp], % (1)\natom(Atom),!, % (2)\nd(Exp,X,DExp), % (3)\ndf(Atom, Exp, DExpF). % (4)\nСначала надо удостовериться, что E – это функция. Для этого\nпопробуем представить E в виде списка [Atom, Exp] (1,2), где\nAtom – это название функции, а Exp – выражение (аргумент). За-\nтем в строке (3) производим построение производной из аргумен-\nта, а в (4) – обращение к набору правил соответствия функций\nвыражениям-производным:\ndf(sin,E, cos(E)).\ndf(cos,E, -sin(E)).\ndf(ln,E, 1/E).\ndf(exp,E, exp(E)).\nПредикат df(Fun,Exp, DExp) переводит функцию Fun и ее\nаргумент Exp в выражение, представляющее производную DExp .\nВ этот список необходимо самостоятельно добавить другие из-\nвестные функции.\nПерейдем к дифференцированию конкретных выражений. Про-\nизводная степенной функции, например, реализуется так:\n79 5. Компьютерная алгебра\nd(E^N,X, N*E^(N1)*DE):-!,\nd(E,X,DE),\nN1 is N-1.\nПроверим программу на нескольких выражениях:\n?- d(X^2, X, D).\nD = 2*X^ (2-1)*1.\n?- d(sin(X^2), X, D).\nD = cos(X^2)* (2*X^ (2-1)*1).\n?- d(sin(cos(X^2))*ln(X+Y), X, D).\nD = cos(cos(X^2))* (-sin(X^2)*\n(2*X^ (2-1)*1))*ln(X+Y)+1/\n(X+Y)* (1+0)*sin(cos(X^2)).\nРезультат требует дальнейшего совершенствования – сокра-\nщения выражений. Для этого реализуем два набора правил: фа-\nсадный 1 предикат sim/2 , предназначенный для сокращения вы-\nражений, и предикат r/2 , представляющий собой элементарные\nупрощающие преобразования. Если элементарное преобразова-\nние удалось, то r/2 истинен, иначе он терпит неудачу.\nsim(X, X):-\n% Переменная не сокращается.\nvar(X),!.\nsim(E, R):-\n% Сделать один шаг упрощения.\nr(E,E1),!, % Если удалось, то\nsim(E1,R). % сократить результат еще.\nsim(E,E).\n% Выражение не сокращается.\n1 Фасадный предикат предназначен для запуска пользователем. За фасадом здания скрывается\nвся его сложная конструкция, доступная для понимания только специалистам.\n80 5.1. Символьное дифференцирование\nРеализация sim/2 сильно походит на сортировку списка методом\n«пузырька». Теперь рассмотрим элементарные преобразования:\nr(A+B, A):-B=@=0,!. % A+0 → A\nr(B+A, A):-B=@=0,!. % 0+A → A\nr(A*B, A):-B=@=1,!. % A*1 → A\nr(B*A, A):-B=@=1,!. % 1*A → A\nr(_*B, 0):-B=@=0,!. % A*0 → 0\nr(B*_, 0):-B=@=0,!. % 0*A → 0\nr(A^B, A):-B=@=1,!. % 𝐴 1 → A\nr(A^B, 1):-B=@=0,A\\=@=0,!.\nr(A/B, A):-B=@=1,!.\n% (1)\n% A/1 → A\nr(B/A, A^(-1)):-B=@=1,!.\n% (2)\nВ строке (1) рассматривается случай 𝑎 0 = 𝑎 , при этом исклю-\n0\nчается неопределенность 0 0 = 0 . В строке (2)\n1\n𝑥\nзаменяется на\n𝑥 −1 . В перечисленных правилах используется специальный вид\nунификации =@=/2 , который проверяет структурную эквивалент-\nность аргументов. Представим несколько примеров 1 [16]:\n1 a =@= A false 2 A =@= B true 3 x(A,A) =@= x(B,C) false\n4 x(A,A) =@= x(B,B) true\n5 x(A,A) =@= x(A,B) false\n6 x(A,B) =@= x(C,D) true\nТо есть в сокращаемых выражениях нам важно распознавать\nправильно, где переменная, а где константа во входных пара-\n1 Специальные\nварианты унификаций SWI-Prolog рассматриваются на странице http://www.\nswi-prolog.org/pldoc/man?section=unifyspecial .\n81 5. Компьютерная алгебра\nметрах. Реализация первого правила r/2 в виде r(A+0, A):-!\nприводит к неправильному ответу на запрос 1 :\n?- r(2+X, R).\nX = 0,\nR = 2.\nАвтоматическая унификация Prolog по умолчанию при сопо-\nставлении двух выражений подставляет переменные, символы,\nчисла и другие термы вместо переменных в правое и в левое вы-\nражения так, чтобы они стали одинаковыми. В данном примере\nовеществляется унификация 2+X=A+0 . Если вместо A подставить\n2 , а вместо X – 0 , то получим выражение 2+0=2+0 . В нашем ре-\nдукторе необходимо сокращаемые переменные сохранить как\nпеременные Prolog, чтобы потом можно было вычислять значе-\nния производных в точке:\nr(A+B, AB):-number(A),number(B),!,AB is A+B.\nr(A*B, AB):-number(A),number(B),!,AB is A*B.\nr(A+B, B+A):-number(B),!.\nr(A*B, B*A):-number(B),!.\nr(A+B+C,AB+C):-number(A),number(B),!, AB is A+B.\nr(A*B*C,AB*C):-number(A),number(B),!, AB is A*B.\nr(A+D, A+B+C):- \\+ D=@=_, D=(B+C),!.\nr(A*D, A*B*C):- \\+ D=@=_, D=(B*C),!.\nЭти правила предназначены для переупорядочения слагае-\nмых и сомножителей таким образом, чтобы можно было сокра-\nтить числовые выражения. Два последних правила раскрывают\n1 Последовательность\n82\nслагаемых в запросе имеет принципиальное значение. 5.1. Символьное дифференцирование\n«ненужные скобки», перестраивая древовидное представление\nформулы. Набор правил не полон, есть возможность их попол-\nнить, в частности можно алгоритмизировать операции вычита-\nния и деления. На самом деле цепочки последовательных опера-\nций сложения и вычитания, умножения и деления следует пред-\nставить в виде списков слагаемых и сомножителей. Затем надо\nпроизводить упорядочение элементов этого списка согласно пра-\nвилам представления полиномов, поиск и сокращение однород-\nных членов. Оставим эту задачу как упражнение.\nСледующая группа правил пытается просто вычислить выра-\nжение, если такое возможно. Если не получается вычислить, то\nнужно попытаться сократить аргументы:\nr(E,R):-\ncompound(E),\nground(E),!,\nR is E.\nr(E,R):-\ncompound(E),\nE=..[F|Args],!,\nr(Args,SArgs),\nR=..[F|SArgs],\nE\\=@=R.\nr([],[]):-!.\nr([X|T],[SX|ST]):-!,\nsim(X,SX),\nr(T,ST).\n83 5. Компьютерная алгебра\nПредикат compound/1 проверяет, является ли его аргумент\nсложным выражением, а ground/1 – выражением, не содержа-\nщим свободных переменных. Первое правило, вообще говоря,\nреализовано некорректно: оно будет порождать исключительную\nситуацию, если в выражении встретится символ или список, то\nесть что-то, над чем невозможно выполнить арифметическую\nоперацию.\nВторое правило преобразует структуру к списку, аналогично\nтому, как мы делали с производной суперпозиции функции. Затем\nпроизводится сокращение выражений в аргументах функции. В\nконце выражение собирается из отдельных компонент в результат\nсокращения. Если получилась структура, отличная от исходной,\nто правило завершается удачно.\nПоследние два правила рекурсивно обрабатывают список ар-\nгументов. Теперь рассмотрим пример использования компьютер-\nной алгебры в программе расчета оптимального управления.\n5.2. Оптимальное управление\nРазработка программ численного решения дифференциаль-\nных уравнений, расчеты оптимального управления связаны с\nнеобходимостью аналитических вычислений формул производ-\nных различных функций и их реализации в виде программного\nкода. В принципе, вместо реализации этого этапа разработки\nпрограмм можно использовать численное дифференцирование\nи ограничиться только реализацией исходных функций. Но, как\nпрактически любой численный метод, численное дифференци-\n84 5.2. Оптимальное управление\nрование а) реализуется как итеративная процедура, которая за-\nтрачивает процессорное время на вычисление значения функции\nв нескольких точках; б) вносит дополнительную погрешность\nвычисления, которая заложена уже в самом методе. Использова-\nние аналитического вычисления производных в целом избавляет\nпрограммный код от этих недостатков.\nВ [10] рассмотрен метод вычисления оптимального управле-\nния, названного в честь его автора, академика Льва Семеновича\nПонтрягина, «Принцип максимума Л. С. Понтрягина». В книге\nвводится обозначение\n𝝍 𝑇 𝒙 = 𝜓 𝑖 𝑥 𝑖 = 𝜓 1 𝑥 1 + 𝜓 2 𝑥 2 + … + 𝜓 𝑛 𝑥 𝑛 ,\n𝜓 1 ,\n⎛ 𝜓 , ⎞\n𝝍 = 𝝍(𝑡) = ⎜ 2 ⎟ ,\n⋮\n𝑖 = 1, 2, … , 𝑛;\n𝑥 1 ,\n⎛ 𝑥 , ⎞\n𝒙 = 𝒙(𝑡) = ⎜ 2 ⎟ .\n⋮\n𝜓\n𝑥\n⎝ 𝑛 ⎠\n⎝ 𝑛 ⎠\nВ этом обозначении 𝑥 1 – 𝑖 -я фазовая переменная, 𝝍 𝑇 𝒙 – матрич-\nное произведение двух векторов, 𝜓 𝑖 𝑥 𝑖 – скалярное произведение\nдвух векторов. Фазовые переменные описывают состояние объек-\nта 1 (рис. 5.1) в пространстве, одна переменная – одна координата,\nсоставляющая вектора скорости и т. п. Фазовые переменные 𝑥 𝑖 –\nэто вещественнозначные функции ( 𝑥 𝑖 ∈ ℝ ) времени 𝑥 𝑖 (𝑡) . Верх-\nний индекс в именах переменных и функций используется здесь\nи далее ввиду того, что производные функций по переменным\nбудут указываться в нижнем индексе. Переменные 𝜓 𝑖 = 𝜓 𝑖 (𝑡) –\nобобщение импульса, задающее влияние фазовой переменной\n𝑥 𝑖 (𝑡) на управление в определенные моменты времени. Вектор\n1 Самолета,\nкорабля, автомобиля, природного ресурса и т. д.\n85 5. Компьютерная алгебра\nпеременных 𝒙 = 𝒙(𝑡) называется фазовым вектором объекта\n(рис. 5.1), а вектора, аналогичные 𝒙(𝑡) , – вектор-функциями.\nВ фазовый вектор объекта входят его координаты и вектор ско-\nрости, а также другие физические величины, характеризующие\nсостояние этого объекта в заданный момент времени 𝑡 ∈ [𝑡 𝑜 , 𝑡 1 ] ,\nгде 𝑡 0 – начальный момент времени, а 𝑡 1 – конечный. На рисун-\nке 5.1 изображен самолет и приведен его упрощенный фазовый\nвектор. Переменные 𝑥 1 , 𝑥 2 , … , 𝑥 6 задают координаты самолета\nи величины скоростей по осям, 𝑥 7 , 𝑥 8 – угол рыскания и ско-\nрость его изменения. Далее, аналогично 𝑥 9 , 𝑥 10 – угол горизонта,\n𝑥 11 , 𝑥 12 – угол крена, 𝑥 13 – величина подъемной силы. Перемен-\nная 𝑥 14 задает величину силы тяжести, 𝑥 15 – величина сил, тор-\nмозящих самолет.\n𝑥 9 , 𝑥 10\n𝑥 13\n𝑢 5\n𝑥 15\n𝑥 1 , 𝑥 2 , 𝑥 3 , 𝑥 4 , 𝑥 5 , 𝑥 6\n𝑢 4\n𝑢 2\n𝑢 1\n𝑥 11 , 𝑥 12\n𝑢 3\n𝑥 14\n𝑥 7 , 𝑥 8\nРис. 5.1. Фазовый вектор самолета\nИзменение переменных 𝑥 ̇ 𝑖 (𝑡) во времени в общем случае за-\nдается системой дифференциальных уравнений в частных про-\nизводных:\n𝑥 ̇ 𝑖\n86\n𝑑𝑥 𝑖\n=\n= 𝑓 𝑖 (𝑥 1 , 𝑥 2 , … , 𝑥 𝑛 ) = 𝑓 𝑖 (𝒙);\n𝑑𝑡\n𝒙 ̇ =\n𝑑𝒙\n= 𝒇(𝒙),\n𝑑𝑡\n(5.1) 5.2. Оптимальное управление\nгде вторая форма записи – векторная, причем для краткости па-\nраметр 𝑡 опущен. Уравнения задают, например, влияние геомет-\nрии оперения и силы тяги на вектор скорости самолета, влияние\nвектора скорости и силы тяжести на координаты в трехмерном\nпространстве и т. п. Дифференциальные связи второго порядка,\nнапример влияние координаты объекта на величину силы тяже-\nсти искусственного спутника Земли, также задаются при помощи\nуравнений (5.1).\nЗадав 𝒙(𝑡 0 ) = 𝒙 0 в момент времени 𝑡 0 и решив уравнение (5.1),\nможно рассчитать траекторию изменения объекта (перемещение\nего в пространстве, например), т. е. решить задачу Коши. Теперь\nобобщим уравнение (5.1), преобразуем его в следующий вид:\n𝒙 ̇ = 𝒇(𝒙, 𝒖),\n(5.2)\nгде 𝒖 = 𝒖(𝑡) – управление, которое также зависит от 𝑡 . Предпола-\nгается, что 𝒇 непрерывна по совокупности всех переменных и\nимеет непрерывные производные по каждому 𝑥 𝑖 и 𝑢 𝑖 .\nКак только в параметры 𝒇 добавили 𝒖 , решение дифференци-\nального уравнения (5.2) стало опять многозначным, т. е. траекто-\nрия зависит теперь не только от 𝒙 0 , но и от того, как объектом\nуправляют 𝒖 = 𝒖(𝑡) . На рисунке 5.1 в вектор управления 𝒖 вхо-\nдят величина силы тяги 𝑢 1 , а также 𝑢 1 , 𝑢 2 , … , 𝑢 5 , обозначающие\nвеличины сил, вызванных соответствующей геометрией крыла и\nхвостового оперения: закрылков, элеронов, рулей высоты и на-\nправления. Геометрия крыла и хвостового оперения изменяется\nсистемой управления, например пилотом. Далее будем предпола-\nгать, что самолетом управляет техническое устройство, например\n87 5. Компьютерная алгебра\nкомпьютер с системой датчиков для получения значений элемен-\nтов фазового ветра, а также выработанный им вектор 𝒖 каким-\nлибо образом меняет тягу и геометрию корпуса самолета.\nДля того чтобы «выбрать» из бесконечного количества воз-\nможных решений одно, необходимо из всех возможных траекто-\nрий найти в некотором смысле лучшую. Какая траектория луч-\nше, а какая хуже, определяет функция-критерий, отображающая\nтраектории (или параметры, ее полностью определяющие) на\nнекоторое число из ℝ . В оптимальном управлении такая функ-\nция называется функционалом.\n𝑡 1\n𝐼(𝒙, 𝒖) = ∫ 𝑓 0 (𝒙, 𝒖)𝑑𝑡 → min .\n(5.3)\n𝑡 0\nВ формуле (5.3) функция 𝑓 0 (𝒙, 𝒖) вычисляет (формализует)\nзначение критерия оценки качества траектории тела в момент\nвремени 𝑡 ∈ [𝑡 0 , 𝑡 1 ] . Предполагается, что функция 𝑓 0 дифференци-\nруема по переменным из 𝒙, 𝒖 (так же как и 𝒇 ). Значение функции\n𝑓 0 в конечный момент времени 𝑡 1 не зависит от управления, так\nкак в этот момент управлять 1 объектом уже нет смысла. В связи\nс этим перепишем функционал следующим образом:\n𝑡 1\n𝐼(𝒙, 𝒖) = ∫ 𝑓 0 (𝒙, 𝒖)𝑑𝑡 + 𝐹(𝑡 1 , 𝒙(𝑡 1 )) → min .\n(5.4)\n𝑡 0\nТеперь функция 𝐹(𝑡 1 , 𝒙(𝑡 1 )) будет обозначать качество траекто-\nрии в этот последний момент времени 𝑡 1 , а интегральное выра-\nжение – качество основной части траектории, где объектом еще\nможно управлять.\n1 Переводить\n88\nуправляемый объект в новое состояние «волевым усилием» функции 𝒖. 5.2. Оптимальное управление\nПринцип максимума определяется через функцию Гамильтона\n(гамильтониан), которая имеет следующий вид:\n𝐻(𝑡, 𝒙, 𝝍, 𝒖) = 𝑓 0 (𝒙, 𝒖) + 𝝍 𝑇 𝒇(𝒙, 𝒖).\n(5.5)\nУправление 𝒖 будет оптимальным 𝒖 ∗ с соответствующей оп-\nтимальной траекторией 𝒙 ∗ , если выполняется условие\n𝐻(𝑡, 𝒙 ∗ , 𝝍, 𝒖 ∗ ) ⩾ 𝐻(𝑡, 𝒙 ∗ , 𝝍, 𝒖)\n(5.6)\nдля любого допустимого 𝒖 . Если привести (5.2)–(5.6) в одну си-\nстему и переписать все уравнения через 𝐻 , то получим следую-\nщую задачу оптимального управления [15]:\n{\n𝒙 ̇ = 𝑯 𝝍 , 𝒙(𝑡 0 ) = 𝒙 0 ,\n𝝍 ̇ = −𝑯 𝒙 , 𝝍(𝑡 1 ) = 𝐹(𝑡 1 , 𝒙(𝑡 1 )).\n(5.7)\nТо есть 𝒙 определяется своим левым 𝒙(𝑡 0 ) концом, а 𝝍 – правым\n𝝍(𝑡 1 ) . Иногда 𝝍 называют также функцией, сопряженной 𝒙 .\n5.2.1. Дискретный вариант задачи улучшения управления\nИспользование численных расчетов предполагает постанов-\nку задачи в дискретном времени. Для этого разобьем интервал\n[𝑡 0 , 𝑡 1 ] на 𝑁 равных частей с шагом ℎ = (𝑡 1 − 𝑡 0 )/𝑁 , 𝑁 ∈ ℕ . Дис-\nкретные моменты времени можно обозначать 𝑡 0 , 𝑡 0 + ℎ , 𝑡 0 + 2ℎ, …,\n𝑡 1 − ℎ, 𝑡 1 или, как будет далее использовано в пособии, 𝑡 0 𝑡 1 ,\n𝑡 2 , … 𝑡 𝑗 , … 𝑡 𝑁 . Функцию 𝒙(𝑡)\nв левой части (5.2) заменим на 𝒙(𝑡 𝑗+1 )\nили еще короче 𝒙 𝑗+1 (так же как и остальные переменные) и полу-\nчим дискретный вариант уравнения движения следующего вида:\n𝒙 𝑗+1 = 𝒈 𝑗 = 𝒈(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ),\n𝒙(𝑡 0 ) = 𝒙 0 ,\n𝒙 𝑗 ∈ ℝ 𝑛 ,\n𝑗 ∈ {0, 1, … , 𝑁};\n𝒖 𝑗 ∈ ℝ 𝑚 .\n(5.8)\n(5.9)\n89 5. Компьютерная алгебра\nФормула (5.8) уже не является дифференциальным уравнением,\nи преобразование из (5.2) в (5.8) – теперь задача пользователя\nпрограммы, которую мы разработаем далее. Самый простой спо-\nсоб – применить простую схему интегрирования Эйлера:\n𝒙 𝑗+1 = 𝒙 𝑗 + ℎ𝒇(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ).\nДалее будем предполагать, что пользователь сам задает (5.8).\nКачество траекторий оценим следующим функционалом:\n𝑁−1\n𝐼(𝒙, 𝒖) = ∑ 𝑓 0 (𝑡 𝑗 , 𝒙 𝐽 , 𝒖 𝑗 ) + 𝐹(𝑡 𝑁 , 𝒙 𝑁 ) → min .\n(5.10)\n𝑗=0\nПринцип максимума в данном случае определяется при помо-\nщи дискретного варианта функции Гамильтона\n𝐻 𝑗 = 𝐻(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ) = 𝑓 0 (𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ) + 𝝍 𝑇 (𝑡 𝑗+1 )𝒈(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ).\n(5.11)\nВыпишем теперь принцип максимума\n𝐻(𝑡 𝑗 , 𝒙 ∗𝑗 , 𝝍 𝑗+1 , 𝒖 ∗𝑗 ) ⩾ 𝐻(𝑡 𝑗 , 𝒙 ∗𝑗 , 𝝍 𝑗+1 , 𝒖 𝑗 )\n(5.12)\nдля всех допустимых 𝒖 𝑗 . Сопряженная вектор-функция 𝝍 𝑗 вы-\nчисляется по схеме\n𝝍 𝑇𝑁 = 𝐹 𝒙 (𝑡 𝑁 , 𝒙 𝑁 ),\n𝝍 𝑇𝑗 = 𝝍 𝑇𝑗+1 + 𝑯 𝒙 (𝑡 𝑗 , 𝒙 ∗𝑗 , 𝝍 𝑇𝑗+1 , 𝒖 ∗𝑗 ).\n(5.13)\nУсловиям (5.5) и (5.12) соответствует минимум 𝐼(𝒙, 𝒖). Поиск\nэтого минимума с использованием численного метода основыва-\nется на вычислении градиента 𝐼′(𝒖) (по переменным 𝒖 ):\n𝐼′(𝒖) = 𝑯 𝒖 (𝑡, 𝒙, 𝝍, 𝒖).\n90\n(5.14) 5.2. Оптимальное управление\n5.2.2. Схема алгоритма улучшения первого порядка\nТеперь мы знаем, как вычислять градиент. Используя эти зна-\nния, построим алгоритм улучшения 𝐼(𝒙, 𝒖) . Обозначим через\n⟨𝒙 𝐼 (𝑖), 𝒖 𝐼 (𝑖)⟩ некоторую допустимую траекторию и управление\nна всем отрезке времени [𝑡 0 , 𝑡 1 ] . Цель шага улучшения – найти та-\nкую траекторию ⟨𝒙 𝐼𝐼 (𝑖), 𝒖 𝐼𝐼 (𝑖)⟩ , чтобы 𝐼(𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 ) < 𝐼(𝒙 𝐼 , 𝒖 𝐼 ). Общая\nсхема улучшения выглядит следующим образом:\n1. Задается начальное управление 𝒖 𝐼 (𝑡) . Из уравнения (5.8) и\nусловий (5.9) определяется 𝒙 𝐼 (𝑡) . Вычисляется 𝐼(𝒙 𝐼 , 𝒖 𝐼 ).\n2. Из системы 𝝍 = 𝑯 𝒙 , 𝝍 𝑁 = −𝑭 𝒙 (𝑡 𝑁 , 𝒙 𝑁 ) находим 𝝍,\nгде 𝑯(𝑡 𝑗 , 𝒙 𝑗 , 𝝍 𝑗+1 , 𝒖 𝑗 ) = 𝝍 𝑇𝑗+1 𝒈(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ) − 𝑓 0 (𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 ), произ-\nводная 𝑯 𝒖 находится в точке (𝑡, 𝒙 𝐼𝑗 , 𝝍 𝑗+1 , 𝒖 𝐼𝑗 ) .\n𝑯 𝒖 (𝑡 𝑗 , 𝒙 𝑗 , 𝝍 𝑗+1 , 𝒖 𝑗 ) = 𝒈 𝒖 (𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 )𝝍 𝑗+1 − 𝑓 𝒖 0 (𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝑗 )\nиз (5.9). Задается параметр 𝛼 .\n3. Из системы 𝒙 𝑗+1\n=\n𝒈(𝑡 𝑗 , 𝒙 𝑗 , 𝒖 𝐼 𝑗 𝐼 ), 𝒙(𝑡 0 )\n=\n𝒙 0 , где\n𝒖 𝐼𝐼 = 𝒖 𝐼 + 𝛼𝑯 𝒖 , вычисляется 𝒙 𝐼𝐼 .\n4. Новое управление и значение параметра 𝛼 подсчитываются\nиз решения задачи одномерной минимизации для функцио-\nнала 𝐼(𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 ) → min .\n𝛼\n5. Если 𝐼 (𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 ) ⩾ 𝐼 (𝒙 𝐼 , 𝒖 𝐼 ) (улучшение не произошло), то\nуменьшаем 𝛼 и переходим к следующей итерации, начиная\nс пункта 3.\n91 5. Компьютерная алгебра\n6. Иначе, если 𝐼 (𝒙 𝐼 , 𝒖 𝐼 ) − 𝐼 (𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 ) > 𝜀 , то переходим к следу-\nющей итерации, начиная с пункта 2. Значение 𝜀 – параметр\nточности.\nШестой шаг алгоритма не относится непосредственно к схеме\nулучшения, но он логичен, так как создает итеративный процесс\nпоиска минимума 𝐼(𝒙, 𝒖), т. е. функции 𝒖 оптимального управле-\nния объектом.\n5.2.3. Реализация программы\nАлгоритм реализуем на простом и компактном языке програм-\nмирования Python [5, 9, 17]. Язык является объектноориентиро-\nванным, его дистрибутив содержит огромное количество библио-\nтек. Кроме того, в Интернете находится еще множество других\nбиблиотек и приложений, в том числе библиотеки numpy и sympy .\nБиблиотека numpy включает в себя операции с векторами данных\nи матрицами. При их помощи будем задавать фазовый вектор 𝒙\nв виде переменной-массива X ( X[j]= 𝒙 𝑗 ), траектории, моменты\nвремени, функцию управления и т. п. В библиотеке sympy содер-\nжатся операции вычисления производных из выражений, функ-\nции преобразования и сокращения выражений, а также процеду-\nры преобразования выражений в байт-код виртуальной машины\nPython (компиляции выражений в программный код).\nПрограмму начнем реализовывать с импорта numpy и sympy ,\nбиблиотеки специальных структур-итераторов itertools , си-\nстемной библиотеки os .\n92 5.2. Оптимальное управление\nimport math\nimport numpy, sympy\nimport itertools\nfrom sympy import symbols, diff, Symbol\nimport numpy.linalg\nfrom sympy.utilities.lambdify import lambdify\nimport os\nTupleType=type((1,))\nListType=type([])\nСначала запрограммируем абстрактный класс, представляю-\nщий модель управляемого объекта. В классе необходимо пред-\nставить 𝒙 0 , определить размерности 𝑛 и 𝑚 вектор-функций 𝒙 и\n𝒖 . Вектор U0 ( 𝒖 𝐼 ) необходимо задать как начальное приближение\nсинтезируемого управления:\nclass Model(object):\ndef __init__(self, X0, U0):\nself.X0=atleast_1d(X0)\n# 𝒙 0 должен быть вектором\nself.U0=U0\nself.N=self.X0.shape[0] # Размерность 𝒙\nself.M=U0.shape[1]\n# Размерность 𝒖\ndef F(self, x):\nreturn 0.0\n# Заглушка по умолчанию\ndef g(self, t, x, u):\nraise RuntimeError(”метод реализуется в подклассе”)\ndef f0(self, t, x, u):\nreturn 0.0\n# Заглушка по умолчанию\n93 5. Компьютерная алгебра\nРеализация схемы улучшения – это класс Process , наследую-\nщий все свойства класса VFCalc , реализующего компьютерную\nалгебру над вектор-функциями. Реализацию VFCalc рассмотрим\nдалее, а пока сосредоточимся на схеме улучшения.\nСхема улучшения получает в качестве входных данных в кон-\nструктор __init__ два параметра: model – класс-потомок клас-\nса Model и alpha – параметр 𝛼 . Для вычисления производных\nVFCalc необходимо знать размерности 𝒙 и 𝒖 . Конструктор так-\nже сохраняет функции 𝒇, 𝑓 и 𝐹 в виде специальных структур-\nвыражений sympy , над которыми можно производить операции\nсимвольного дифференцирования:\nclass Process(VFCalc):\ndef __init__(self, model, alpha=1.0):\nVFCalc.__init__(self, model.N, model.M)\nt,x,u=self.v.t,self.v.x,self.v.u\nself.model=model; self.alpha=alpha\nself.v.g=model.g(t, x, u) # Получить выражение 𝒈\nself.v.f0=model.f0(t, x, u) # Получить выражение 𝑓 0\nself.v.F=model.F(x) # Получить выражение 𝐹\ndef trajectory(self, U):\n# Расчет траектории 𝒙(𝑡)\nx0=self.model.X0; X = [x0] # по известному 𝒖\nfor t, u in enumerate(U): # (0, u0), (1, u1)\nxn=self.model.g(t, X[t], u); X.append(xn)\nreturn array(X)\ndef I(self, X, U):\n# Вычисление 𝐼(𝒙, 𝒖)\ndef _a(acc, t):\nreturn acc + self.model.f0(t, X[t], U[t])\nreturn reduce(_a, range(len(X)-1), self.model.F(X[-1]))\n94 5.2. Оптимальное управление\ndef optimize(self, t, eps=0.001, iters=1000): # Схема\nUp=self.model.U0\n# (𝒙 𝐼 , 𝒖 𝐼 )\nXp=self.trajectory(Up)\nIp=self.I(Xp,Up); it = 1\n# 𝐼(𝒙 𝐼 , 𝒖 𝐼 )\nwhile True:\nalpha = self.alpha\nPsi=self.Psi(t, Xp, Up)\n# 𝝍(𝑡)\n_H_u=self.H((self.v.u,), t[:-1], Xp[:-1], Up, Psi)\nwhile True:\n_dU=_H_u*alpha\n# 𝑯 𝒖 𝛼\nUn = Up + _dU\nXn = self.trajectory(Un) # (𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 )\nIn = self.I(Xn, Un)\n# 𝐼(𝒙 𝐼𝐼 , 𝒖 𝐼𝐼 )\ndI = Ip-In\nif abs(dI)<eps:\n# Решение найдено\nreturn In, Xn, Un, it, ”opt”\nif iters<=0:\n# Решение не найдено\nreturn In, Xn, Un, it, ”nonoptimal”\niters-=1; it+=1\nif In>=Ip:\nalpha/=2 # Новый параметр\ncontinue # шага улучшения\nelse:\nXp, Up, Ip = Xn, Un, In\nbreak\nВ предыдущем отрезке программного кода переменные X , U\nи их аналоги – это массивы значений 𝒙(𝑡) и 𝒖(𝑡) для каждого\nмомента времени 𝑡 на интервале [𝑡 0 , 𝑡 1 ] .\nВычисления 𝝍 и нужной производной 𝑯 реализуются при по-\nмощи специальных методов класса Process , которые описаны\n95 5. Компьютерная алгебра\nдалее. Операция dot(A,B) выполняет матричное умножение ар-\nгументов. Если в качестве параметра этой операции передать два\nвектора-строки, то второй вектор будет автоматически транспо-\nнирован в столбец. Эта особенность реализации в библиотеке\nnumpy позволяет тривиальные матричные умножения векторов\nделать без дополнительной явной операции транспонирования.\nВ результате операции X[:-1] возвращается последний « -1 » эле-\nмент X , т. е. 𝒙(𝑡 1 ) :\ndef Psi(self, t, X, U):\nv=self.v\npsie = -self.fun(v.F,(v.x,), t[-1], X[-1], U[-1])\npsi=[psie]; X=X[:-1]; t=t[:-1]\n_f0_x=self.fun(v.f0, (v.x,), t, X, U) # 𝑓 𝒙 0\n_g_x =self.fun(v.g, (v.x,), t, X, U)\nj=len(t)-1; p=psie\n# 𝒈 𝒙\n# Начать с конца интервала\nwhile j>=1:\ni=t[j]; pp=p\npn = dot(pp, _g_x[i]) - _f0_x[i]\npsi.append(pn); p=pn; j-=1\npsi=array(psi)\nreturn psi[::-1]\n# Переставить в обратном порядке\ndef H(self, vars, T, X, U, Psi):\ng=self.fun(self.v.g, vars, T, X, U)\nf0=-self.fun(self.v.f0, vars, T, X, U)\nH = alpha * f0\nfor psi,_H,_g,i in zip(Psi, H, g, range(len(H))):\n_H += dot(psi,_g); H[i]=_H\nreturn H\n96 5.2. Оптимальное управление\nВ приведенном отрезке кода в H передается список векторов\nпеременных, по которым вычисляются производные 𝑯 , значения\n𝒙 и 𝒖 на всем интервале времени, а также сам интервал времени\nи параметр 𝛼 .\nФункции 𝒈, 𝑓 0 и 𝐹 , задаваемые пользователем нашей биб-\nлиотеки решения задач оптимального управления, в программе\nмогут получить значения как в определенный момент времени\n(например, X[:-1] ), так и на всем интервале ( X ). Кроме того, фор-\nмулы производных от 𝑔 𝑖 могут «вырождаться» в константы, т. е.\ng может выдать не вектор значений, когда это надо, а просто одно\nчисловое значение. Для того чтобы меньше зависеть от этих слу-\nчаев, необходимо реализовать специальную функцию, которая\nвозвращала бы адекватный по типу результат типу переданных\nей параметров. А вот внутри функции должно вычисляться зна-\nчение нужной нам производной нужной нам функции. Такой\nфункцией в Process является метод fun .\ndef fun(self, f, vars, T, X, U):\ncode,df=self.code(f, *vars) # Найти производную\n# и скомпилировать ее.\nX=numpy.atleast_1d(X) # Входной параметры X и U\nU=numpy.atleast_1d(U) # должны быть векторами.\nif X.ndim>1:\nXs=[X[:,i:i+1] for i in range(X.shape[1])]\nUs=[U[:,i:i+1] for i in range(U.shape[1])]\nargs=(T,)+tuple(Xs+Us)\nelse:\nargs=(T,)+tuple(X)+tuple(U)\nrc=code(*args)\n# Вычислить функцию (производную)\nrct=type(rc)\n97 5. Компьютерная алгебра\nrc=numpy.atleast_1d(rc)\nif type(T)==numpy.ndarray:\ntry: # Попробовать транспонировать список\nif rct in [TupleType,ListType]:\nrc=rc.reshape(rc.shape[:-1])\nrc=rc.T\nreturn rc\nexcept ValueError: pass # ... не получилось\nif T.shape[0]!=rc.shape[0]: # Константа → вектор\nnrc=numpy.zeros((len(T),)+rc.shape,dtype=float)\nnrc[:]=rc; rc=nrc\nreturn rc\n5.2.4. Дифференцирование вектор-функций\nТеперь рассмотрим подсистему вычисления производных век-\nтор-функций. Для этого разработаем специальный класс, экзем-\nпляры которого настроены на поддержку нашей программы, реа-\nлизующей схему улучшения.\nЭкземпляры прежде всего должны знать, какого размера N\nфазовый вектор 𝒙 и вектор управления 𝒖 ( M ). Эти параметры пе-\nредаются в конструктор класса VFCalc при создании экземпляра.\nДалее порождается ряд символов, специальных структур биб-\nлиотеки sympy , обозначающих идентификаторы в выражениях.\nПри помощи этих символов записываются функции, из которых\nбудут вычисляться производные.\nКласс VFCalc , кроме сервиса вычисления производных, предо-\nставляет возможности компиляции полученных выражений в\nбайт-код виртуальной машины среды исполнения Python . Так\n98 5.2. Оптимальное управление\nкак класс VFCalc является базовым для класса Process , то его\nопределение в тексте программы должно быть помещено перед\nопределением Process .\nclass Helper():\npass\nclass VFCalc(object):\ndef __init__(self, N,M):\nself.N=N; self.M=M; self.v=Helper()\nself.v.x=[Symbol(’x’+str(i+1)) for i in range(self.N)]\nself.v.u=[Symbol(’u’+str(i+1)) for i in range(self.M)]\nself.v.t=Symbol(’t’)\n# Переменные для представления\n#\ndef diff1(self, f, var):\nвыражений\n# Шаг вычисления производной\nif type(f) in [TupleType,ListType]:\ndf=tuple([self.diff1(fi, var) for fi in f])\nelse:\ndf=tuple([diff(f, vi) for vi in var])\nif len(df)==1: df=df[0] # Лишние скобки\nreturn df\ndef diff(self, f, *vars): # Производная вектор-функции\ncf=f\nfor v in vars:\n# Выполнить пошагово\ncf=self.diff1(cf, v)\nreturn cf\ndef subs(self, f, s):\n# Подстановка в вектор-функцию\nif type(f) not in [TupleType,ListType]:\nreturn f.subs(s)\nreturn tuple([self.subs(fi,s) for fi in f])\n99 5. Компьютерная алгебра\ndef lambdify(self, f):\n# Компилирование вектор-функции\nl=[self.v.t] # Формирование списка\nl.extend(self.v.x) #\nпараметров\nl.extend(self.v.u)\nfl=lambdify(l, f, ”numpy”) # Использовать арифметику\nreturn fl\n#\nиз пакета numpy\ndef code(self, f, *vars): # Вычислить производную\ndf=self.diff(f, *vars)\nc=self.lambdify(df) # и скомпилировать ее.\nreturn c,df # Возвратить оба результата\nТестирование класса произведем при помощи следующего\nпрограммного кода:\nd=VFCalc(2,2)\nx1,x2=Symbol(’x1’),Symbol(’x2’)\nu1,u2=Symbol(’u1’),Symbol(’u2’)\ny1=x1**2*u1+x2*u2**2\ny2=x1**2*x2**2*u1**2*u2**2\nres=(d.diff([y1,y2],\n[x1,x2], [u1,u2]))\npprint (res)\nreturn\nВ приведенном коде x1 и x2 – переменные, формирующие\nвектор переменных 𝒙 , u1 и u2 – переменные, формирующие век-\nтор переменных 𝒖 , функции y1 и y2 формируют вектор-функцию\n𝒇 , из которой берется производная 𝒇 𝒙𝒖 . В результате получаем\nследующую матрицу функций:\n(((2*x1, 0), (0, 2*u2)),\n((4*u1*u2**2*x1*x2**2,\n100 5.2. Оптимальное управление\n4*u1**2*u2*x1*x2**2),\n(4*u1*u2**2*x1**2*x2,\n4*u1**2*u2*x1**2*x2)))\n5.2.5. Тестирование программы\nТестирование программы проведем на простой модели:\n𝑔 1 = 𝑥 1 (𝑡 𝑗 ) + ℎ𝑢 1 (𝑡 𝑗 ),\n𝑓 0 = ℎ(𝑥 1 2 + 𝑢 21 ),\nℎ = 0.01,\n𝑥 1 (𝑡 0 ) = 1.0,\n𝐹 = 0.0,\n𝑡 0 = 0.0,\n𝑡 𝑖 = 𝑡 0 + ℎ(𝑖 − 1),\n𝑡 𝑁 = 𝑡 1 = 1.0,\n𝒖 𝐼 = 0.0.\nМодель реализуем в виде класса, унаследовав его от Model :\nclass LinModel1(Model):\ndef __init__(self):\nX0=(1.0,)\nself.h = 0.01\nself.num = int((1.0-0.0) / self.h) # num= 𝑁\nself.T = linspace(start=0.0, stop=1.0, num=self.num)\nself.t = arange(len(self.T))\n# 0,1,2,3,4,5...\nModel.__init__(self, X0=X0, U0=self.start_control())\ndef start_control(self):\n# 𝒖 𝐼 =0.0\nU = [(0.0,) for t in self.t[:-1]]\nreturn array(U)\ndef F(self, x):\nreturn 0.0\n101 5. Компьютерная алгебра\ndef g(self, t, x, u):\nx0=x[0]; u0=u[0]\nreturn (x0+self.h*u0,)\n# Схема Эйлера для 𝑥 1 ̇ = 𝑢 1 .\ndef f0(self, t, x, u):\nx0=x[0]; u0=u[0]\nreturn self.h * (x0*x0+u0*u0)\nТеперь создадим экземпляр задачи, передадим его в качестве\nпараметра в процесс улучшения, который тоже является экзем-\nпляром своего класса. Проведем тестовый запуск:\ndef test_1():\nm = LinModel1()\n# Модель\np1=Process(m, alpha=1.0) # Процесс улучшения\niters=2000 # Максимальное количество итераций\neps=0.001 # Точность аппроксимации минимума 𝐼\nrc=I1, X1, U1, it1, rstr =\np1.optimize(m.t, eps=eps, iters=iters)\nprint (I1, ”iters:”, it1)\ntest_1()\n# Запуск теста\nВ результате запуска вычислений получим результат следую-\nщего вида:\n0.776664425757 iters: 47.\nПолучается, что за 47 итераций получены управление и траек-\nтория, оцениваемая минимальным функционалом со значением\n0,777. Траектория и управление изображены на рис. 5.2. На ри-\nсунке нижняя линия – это синтезированное оптимальное управ-\nление, а верхняя – траектория.\n102 5.2. Оптимальное управление\n1\nX\nU\n0.8\n0.6\n0.4\n0.2\n0\n-0.2\n-0.4\n-0.6\n0\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n1\nРис. 5.2. Результат расчета оптимального управления задачи\n5.2.6. Резюме\nМы рассмотрели практическое приложение процедур вычис-\nления частных производных из функций. На самом деле данные\nпроцедуры не являются в полной мере реализациями какого-ли-\nбо метода искусственного интеллекта, но они демонстрируют,\nкак при помощи синтеза (гибридизации) численного моделирова-\nния и символьных вычислений разрабатываются полезные при-\nложения, а также экономится труд математиков и программистов:\nпоскольку нет необходимости в выписывании и программирова-\nнии процедур вычисления производных вектор-функций.\nСущественным недостатком разработанной программы явля-\nется низкая производительность функции fun , так как она вы-\nчисляет производные заново при каждом обращении. Сделано\nэто для того, чтобы не усложнять тексты программ в пособии.\nПроблема решается при помощи реализации механизма кеши-\nрования: вычислив производную из какой-либо функции, надо\n103 5. Компьютерная алгебра\nсохранить ее копию в кеше. Дальнейшим развитием изложенно-\nго подхода к разработке программного обеспечения численных\nметодов является порождение программ, реализующих метод на\nоснове анализа или интерпретации Python-программы. Интерес-\nным также является разработка библиотеки или программного\nпакета, при помощи которого можно было бы задавать уравнение\nдвижением в непрерывной форме вместе со схемой ее перевода\nв дискретный вид для численного решения, а по полученной схе-\nме опять же генерировать высокопроизводительную программу,\nреализация которой учитывает особенности микропроцессора.\n104 Заключение\nВ учебном пособии приведен ряд задач искусственного ин-\nтеллекта, решения которых представлены в виде программ на\nлогическом языке программирования Prolog. Представлены как\nклассические, относящиеся к планированию действий, поиску\nрешения с удовлетворением ограничений, так и задачи, апеллиру-\nющие к специфике численных методов решения дифференциаль-\nных уравнений и поиска оптимального управления движением.\nОтдельно рассмотрено применение логического языка для орга-\nнизации символьных вычислений. Свойства логического языка\nпрограммирования позволяют программисту развить навыки ло-\nгического мышления и серьезное отношение к своей программе\nне просто как к некоторому набору операторов, а как к строгой\nлогической конструкции. Причем это касается не только языков\nпрограммирования высокого уровня, таких как Prolog, Refal, и\nязыков функционального программирования, но и языков импе-\nративных: С/С++/С#, Pascal, Visual Basic и т. д.\nЗа рамками пособия остались такие интересные темы, как\n«Эволюционные вычисления», «Решение игровых задач», «Экс-\nпертные системы», «Анализ данных» и др.\nНадеемся, что задача пособия – рассказать, на каких прин-\nципах работают современные системы компьютерной алгебры,\nвыполнена, а студенты-читатели с интересом знакомились с раз-\nделами пособия и выполняли задания. Надеемся также, что те-\nматика учебного пособия теперь будет представлять научный\nинтерес для читателей.\n105 Заключение\nЗадачи, рассмотренные в пособии, всегда присутствуют в лю-\nбом производственном процессе, связанном с обработкой инфор-\nмации, но, к сожалению, они остаются незамеченными. Достаточ-\nно просто распознать вычислительную задачу, труднее – задачу,\nсвязанную с математическим моделированием, и совсем трудно –\nзадачу автоматизации рассуждений и принятия решения. Читате-\nлю следует и далее уделять некоторое время развитию навыков\nпрограммирования систем искусственного интеллекта и анализу\nбизнес-процессов предприятия с целью выявления и решения\nэтих необычных задач.\nУспехов в изучении методов искусственного интеллекта!\nhttp://eugeneai.github.io/ais/\n106 Рекомендуемая литература\n1. Братко И. Программирование на языке ПРОЛОГ для искус-\nственного интеллекта : пер. с англ. / И. Братко. – М. : Мир,\n1990. – 560 c.: ил.\n2. Васильев С. Н. Интеллектное управление динамическими\nсистемами / С. Н. Васильев, А. К. Жерлов, Е. А. Федосов,\nБ. Е. Федунов. – М. : Физматлит, 2000. – 352 с: ил.\n3. Искусственный интеллект : в 3 кн. / под ред. Э. В. Попова. –\nМ. : Радио и связь, 1990. – 464 c.: ил.\n4. Лорьер. Ж.-Л. Системы искусственного интеллекта : пер. с\nфранц. / Ж.-Л. Лорьер. – М. : Мир, 1991. – 568 с.: ил.\n5. Лутц М. Изучаем Python, 4-е издание.: пер. с англ. / М. Лутц.\nСПб.:Символ-Плюс, 2011. 1280 с., ил.\n6. Математический энциклопедический словарь / гл. ред.\nЮ. В. Прохоров. – М. : Сов. энциклопедия, 1988. – 847 c.\n7. Непейвода Н. Н. Основания программирования / Н. Н. Непей-\nвода, И. Н. Скопин. – Москва; Ижевск : Институт компьютер-\nных исследований, 2003 – 880 c.: ил.\n8. Непейвода Н. Н. Прикладная логика : учеб. пособие /\nН. Н. Непейвода. – 2-е изд. – Новосибирск : Изд-во Ново-\nсиб. ун-та, 2000. – 521 c.: ил.\n9. Основы программирования на Python. [Электронный\nресурс]:\nсайт.\nURL: http://younglinux.info/sites/\ndefault/files/python_structured_programming.pdf .\n(дата обращения: 11.01.2015).\n10. Понтрягин Л. С. Принцип максимума в оптимальном управ-\n107 Рекомендуемая литература\nлении / Л. С. Понтрягин. 2-е изд. М. : Едиториал УРСС,\n2004. – 64 с.\n11. Рассел С. Искусственный интеллект: современный подход :\nпер. с англ. / С. Рассел, П. Новриг. 2-е изд. – М. : Изд. дом\n«Вильямс», 2006. – 1408 c.: ил.\n12. Тарифное руководство № 4. Книга 2. Часть 1. Алфавитный\nсписок железнодорожных станций. [Электронный ресурс]:\nсайт. http://mapservis.ru/docs/tar_ruc_4.htm (дата об-\nращения: 06.05.2015).\n13. The GNU Prolog web site [Электронный ресурс]: сайт.\nURL: http://www.gprolog.org/ .\n(дата\nобращения:\n28.11.2013).\n14. OpenStreetMap Nominatim: Search. [Электронный ре-\nсурс]: сайт. URL: http://wiki.openstreetmap.org/wiki/\nNominatim . (дата обращения: 11.01.2015).\n15. Sethi S. P., Thomson G. L. Optimal Control Theory: Applications\nto Management Science and Economics. 2nd Edition. 2005.\n506 pp.\n16. SWI-Prolog’s home [Электронный ресурс]: сайт. URL: http:\n//www.swi-prolog.org/ . (дата обращения: 28.11.2013).\n17. Welcome to Python.org. [Электронный ресурс]: сайт.\nURL: https://www.python.org/\n11.01.2015).\n108\n(дата\nобращения: "
